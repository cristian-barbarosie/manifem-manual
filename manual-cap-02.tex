
          %--------------------%
\chapter{~~Meshes and manifolds; patchwork}\label{\numb section 2}
          %--------------------%

This section describes several examples of meshes, some of them built on specific manifolds.
Note that in this manual we use the term ``manifold'' to mean a manifold without boundary.

This section focuses on building meshes by joining together several regular meshes
(triangles or quadrangles), like patches.
In contrast, section \ref{\numb section 3} shows how to mesh regions of a manifold
by progressively adding triangular cells, one by one.

Paragraphs \ref{\numb section 2.\numb parag 4}, \ref{\numb section 2.\numb parag 5},
\ref{\numb section 2.\numb parag 9} and \ref{\numb section 2.\numb parag 11} deal
with one-dimensional meshes (curves) in $ \mathbb{R}^2 $,
paragraphs \ref{\numb section 2.\numb parag 13}, \ref{\numb section 2.\numb parag 14},
\ref{\numb section 2.\numb parag 15} and \ref{\numb section 2.\numb parag 16} show
curves in $ \mathbb{R}^3 $,
paragraphs \ref{\numb section 2.\numb parag 1}, \ref{\numb section 2.\numb parag 2},
\ref{\numb section 2.\numb parag 3}, \ref{\numb section 2.\numb parag 9} and
\ref{\numb section 2.\numb parag 11} show plane domains
(two-dimensional meshes in $ \mathbb{R}^2 $),
while paragraphs \ref{\numb section 2.\numb parag 6}, \ref{\numb section 2.\numb parag 7},
\ref{\numb section 2.\numb parag 8}, \ref{\numb section 2.\numb parag 13},
\ref{\numb section 2.\numb parag 14}, \ref{\numb section 2.\numb parag 17} and
\ref{\numb section 2.\numb parag 18} focus on two-dimensional meshes
in $ \mathbb{R}^3 $ (surfaces).

Paragraphs \ref{\numb section 2.\numb parag 4} -- \ref{\numb section 2.\numb parag 14}
are about manifolds defined implicitly as level sets;
paragraphs \ref{\numb section 2.\numb parag 15} -- \ref{\numb section 2.\numb parag 18}
describe parametric manifolds.


          %----------------%
\section{~~Joining segments}\label{\numb section 2.\numb parag 1}
          %----------------%

Here is another way of meshing the same L-shaped domain as in paragraph
\ref{\numb section 1.\numb parag 4} :

\begin{figure}[ht] \centering
  \psfrag{A}{\small\tt\textcolor{textindraw}{A}}
  \psfrag{B}{\small\tt\textcolor{textindraw}{B}}
  \psfrag{C}{\small\tt\textcolor{textindraw}{C}}
  \psfrag{D}{\small\tt\textcolor{textindraw}{D}}
  \psfrag{E}{\small\tt\textcolor{textindraw}{E}}
  \psfrag{F}{\small\tt\textcolor{textindraw}{F}}
  \psfrag{G}{\small\tt\textcolor{textindraw}{G}}
  \psfrag{H}{\small\tt\textcolor{textindraw}{H}}
  \includegraphics[width=95mm]{L-shaped-distorted}
  \caption{An L-shaped mesh again}
  \label{\numb section 2.\numb fig 1}
\end{figure}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 1}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Mesh} \azul{AG} ( \textcolor{tag}{tag}::segment, A .reverse(), G, \textcolor{tag}{tag}::divided_in, \laranja{22} );
   \verm{Mesh} \azul{GH} ( \textcolor{tag}{tag}::segment, G .reverse(), H, \textcolor{tag}{tag}::divided_in,  \laranja{8} );
   \verm{Mesh} \azul{HC} ( \textcolor{tag}{tag}::segment, H .reverse(), C, \textcolor{tag}{tag}::divided_in, \laranja{12} );
   \verm{Mesh} \azul{CD} ( \textcolor{tag}{tag}::segment, C .reverse(), D, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Mesh} \azul{HD} ( \textcolor{tag}{tag}::join, HC, CD );
   \verm{Mesh} \azul{DA} ( \textcolor{tag}{tag}::segment, D .reverse(), A, \textcolor{tag}{tag}::divided_in,  \laranja{8} );
   \verm{Mesh} \azul{CE} ( \textcolor{tag}{tag}::segment, C .reverse(), E, \textcolor{tag}{tag}::divided_in,  \laranja{7} );
   \verm{Mesh} \azul{EF} ( \textcolor{tag}{tag}::segment, E .reverse(), F, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Mesh} \azul{FD} ( \textcolor{tag}{tag}::segment, F .reverse(), D, \textcolor{tag}{tag}::divided_in,  \laranja{7} );
   \verm{Mesh} \azul{AGHD} ( \textcolor{tag}{tag}::rectangle, AG, GH, HD, DA );
   \verm{Mesh} \azul{CEFD} ( \textcolor{tag}{tag}::rectangle, CE, EF, FD, CD .reverse() );
   \verm{Mesh} \azul{L_shaped} ( \textcolor{tag}{tag}::join, AGHD, CEFD );
\end{Verbatim}

The only difference between this mesh and the one presented in paragraph
\ref{\numb section 1.\numb parag 4} is a slight distortion in the lower half of the domain,
due to the non-uniform distribution of the vertices along {\small\tt HD}.

Paragraph \ref{\numb section 11.\numb parag 2} explains the coloring conventions used in
this manual for {\tt C++} code.
Paragraph \ref{\numb section 11.\numb parag 3} gives details about \textcolor{tag}{tag}s.


          %---------%
\section{~~Exercise}\label{\numb section 2.\numb parag 2}
          %---------%

Build the mesh shown in figure \ref{\numb section 2.\numb fig 2}.
We ask for one connected mesh, that is, the triangle and the rectangle must share some vertices
(and segments, reversed).

\begin{figure}[ht] \centering
  \psfrag{A}{\small\tt\textcolor{textindraw}{A}}
  \psfrag{B}{\small\tt\textcolor{textindraw}{B}}
  \psfrag{C}{\small\tt\textcolor{textindraw}{C}}
  \psfrag{D}{\small\tt\textcolor{textindraw}{D}}
  \psfrag{E}{\small\tt\textcolor{textindraw}{E}}
  \psfrag{F}{\small\tt\textcolor{textindraw}{F}}
  \psfrag{G}{\small\tt\textcolor{textindraw}{G}}
  \psfrag{H}{\small\tt\textcolor{textindraw}{H}}
  \includegraphics[width=130mm]{arrow}
  \caption{An arrow}
  \label{\numb section 2.\numb fig 2}
\end{figure}


          %-------------------------------%
\section{~~Triangular meshes on rectangles}\label{\numb section 2.\numb parag 3}
          %-------------------------------%

On a rectangular domain, we can build a mesh of triangles by using the {\small\tt\verm{Mesh}}
constructor with {\small\tt\textcolor{tag}{tag}::rectangle}, providing as last argument the
{\small\tt\textcolor{tag}{tag}::with\_\,triangles}.
For instance, in the example \ref{\numb section 1.\numb parag 4},
if we re-write the definition of {\small\tt BGHC} as

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \verm{Mesh} \azul{BGHC} ( \textcolor{tag}{tag}::rectangle, BG, GH, HC, BC .reverse(), \textcolor{tag}{tag}::with_triangles );
\end{Verbatim}

\noindent we get the mesh shown in figure \ref{\numb section 2.\numb fig 3}.

\begin{figure}[ht] \centering
  \psfrag{A}{\small\tt\textcolor{textindraw}{A}}
  \psfrag{B}{\small\tt\textcolor{textindraw}{B}}
  \psfrag{C}{\small\tt\textcolor{textindraw}{C}}
  \psfrag{D}{\small\tt\textcolor{textindraw}{D}}
  \psfrag{E}{\small\tt\textcolor{textindraw}{E}}
  \psfrag{F}{\small\tt\textcolor{textindraw}{F}}
  \psfrag{G}{\small\tt\textcolor{textindraw}{G}}
  \psfrag{H}{\small\tt\textcolor{textindraw}{H}}
  \includegraphics[width=108mm]{L-shaped-tri}
  \caption{An L-shaped mesh with triangular cells}
  \label{\numb section 2.\numb fig 3}
\end{figure}

If we give the sides of the rectangle in a different order, like in

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \verm{Mesh} \azul{BGHC} ( \textcolor{tag}{tag}::rectangle, GH, HC, BC .reverse(), BG, \textcolor{tag}{tag}::with_triangles );
\end{Verbatim}

\noindent the rectangles will be cut along the other diagonal (check it yourself).

The mesh in paragraph \ref{\numb section 1.\numb parag 5} could have been built like this :

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \verm{Mesh} \azul{ABD} ( \textcolor{tag}{tag}::triangle, AB, BD, AD .reverse() );
   \verm{Mesh} \azul{BCED} ( \textcolor{tag}{tag}::quadrangle, CE, ED, BD .reverse(), BC, \textcolor{tag}{tag}::with_triangles );
   \verm{Mesh} \azul{one_tri_one_rect} ( \textcolor{tag}{tag}::join, ABD, BCED );
\end{Verbatim}


          %-----------------------------------------------------%
\section{~~A manifold defined as a level set in $ \mathbb{R}^2 $}
          %-----------------------------------------------------%
\label{\numb section 2.\numb parag 4}

{\ManiFEM} allows one to define manifolds and submanifolds, and this feature may be
used to build domains of the desired shape.

Until now, we have only met the trivial Euclidian manifold, defined as {\small\tt
\verm{Manifold}\break ( \textcolor{tag}{tag}::Euclid,} {\small\tt\textcolor{tag}{tag}::of\_\,dim,}
{\small\tt n} {\small\tt )}.
One can define a submanifold in terms of an implicit equation, that is, as a level set,
using the method {\small\tt implicit} of the Euclidian manifold.
The code below introduces a one-dimensional submanifold of $ \mathbb{R}^2 $ (a hiperbola).

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 4}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} \azul{RR2} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{2} );
   \verm{Function} \azul{xy} = RR2 .build_coordinate_system ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );
   \verm{Function} \azul{x} = xy [\laranja{0}], \azul{y} = xy [\laranja{1}];
   
   \verm{Manifold} \azul{hiperbola} = RR2 .implicit ( x*y == \laranja{1.} );
   
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  x (A) =  \laranja{0.5};   y (A) =  \laranja{2.};
   \verm{Cell} \azul{B} ( \textcolor{tag}{tag}::vertex );  x (B) =  \laranja{3};     y (B) =  \laranja{0.333333333333};
   \verm{Mesh} \azul{arc_of_hiperbola} ( \textcolor{tag}{tag}::segment, A .reverse(), B, \textcolor{tag}{tag}::divided_in, \laranja{7} );
   arc_of_hiperbola .draw_ps (\verde{"hiperbola.eps"});
   arc_of_hiperbola .export_to_file ( \textcolor{tag}{tag}::msh, \verde{"hiperbola.msh"});
\end{Verbatim}

\begin{figure}[ht] \centering
  \psfrag{A}{\small\tt\textcolor{textindraw}{A}}
  \psfrag{B}{\small\tt\textcolor{textindraw}{B}}
  \includegraphics[width=85mm]{hiperbola}
  \caption{An arc of hiperbola}
  \label{\numb section 2.\numb fig 4}
\end{figure}

In {\tt gmsh}, you must select {\small\tt Tools} $\to$ {\small\tt Options} $\to$
{\small\tt Mesh} $\to$ {\small\tt 1D Elements} in order to see this mesh.

Note that the vertices are not perfectly uniformly distributed along the curve
because they are obtained as projections of points uniformly distributed along
the straight segment {\small\tt AB} onto the {\small\tt hiperbola} manifold.

Note also that when defining individual points {\small\tt A} and {\small\tt B} we must
be careful to set coordinates {\small\tt x} and {\small\tt y} within
the {\small\tt hiperbola} manifold.
As an alternative, we might explicitly project them onto the {\small\tt hiperbola} like this :

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \verm{Cell} \azul{P} ( \textcolor{tag}{tag}::vertex );  x (P) = \laranja{0.6};  y (P) = \laranja{2.1};
   hiperbola .project (P);
\end{Verbatim}

\noindent In contrast, the {\small\tt\verm{Mesh}} constructor with
{\small\tt\textcolor{tag}{tag}::segment} builds points in the surrounding space {\small\tt RR2}
and then projects them onto the {\small\tt hiperbola} without the user's assistance.

The projection is done by applying a few steps of Newton's method for under-determined
(systems of) equations, as explained in paragraph \ref{\numb section 8.\numb parag 1}.

Paragraph \ref{\numb section 3.\numb parag 5} shows another way of meshing a curve,
producing equidistant vertices.


          %----------------------------------------%
\section{~~A circle defined by four curved segments}\label{\numb section 2.\numb parag 5}
          %----------------------------------------%

We can define several arcs of curve and {\small\tt join} them, thus obtaining a closed curve :
\medskip

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 5}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Cell} \azul{N} ( \textcolor{tag}{tag}::vertex );  x (N) =  \laranja{0.};  y (N) =  \laranja{1.};
   \verm{Cell} \azul{W} ( \textcolor{tag}{tag}::vertex );  x (W) = \laranja{-1.};  y (W) =  \laranja{0.};
   \verm{Cell} \azul{S} ( \textcolor{tag}{tag}::vertex );  x (S) =  \laranja{0.};  y (S) = \laranja{-1.};
   \verm{Cell} \azul{E} ( \textcolor{tag}{tag}::vertex );  x (E) =  \laranja{1.};  y (E) =  \laranja{0.};
   \verm{Mesh} \azul{NW} ( \textcolor{tag}{tag}::segment, N .reverse(), W, \textcolor{tag}{tag}::divided_in, \laranja{5} );
   \verm{Mesh} \azul{WS} ( \textcolor{tag}{tag}::segment, W .reverse(), S, \textcolor{tag}{tag}::divided_in, \laranja{5} );
   \verm{Mesh} \azul{SE} ( \textcolor{tag}{tag}::segment, S .reverse(), E, \textcolor{tag}{tag}::divided_in, \laranja{5} );
   \verm{Mesh} \azul{EN} ( \textcolor{tag}{tag}::segment, E .reverse(), N, \textcolor{tag}{tag}::divided_in, \laranja{5} );
   \verm{Mesh} \azul{circle} ( \textcolor{tag}{tag}::join, NW, WS, SE, EN );
\end{Verbatim}

\begin{figure}[ht] \centering
  \psfrag{N}{\small\tt\textcolor{textindraw}{N}}
  \psfrag{S}{\small\tt\textcolor{textindraw}{S}}
  \psfrag{E}{\small\tt\textcolor{textindraw}{E}}
  \psfrag{W}{\small\tt\textcolor{textindraw}{W}}
  \includegraphics[width=70mm]{circle}
  \caption{A circle obtained by {\small\tt join}ing four segments}
  \label{\numb section 2.\numb fig 5}
\end{figure}

Again, the distribution of vertices along the circle is not perfect
because vertices are obtained as projections (on the circle) of points
along straight segments {\small\tt NW}, {\small\tt WS} and so forth.
Paragraph \ref{\numb section 3.\numb parag 2} shows another way of meshing a closed curve,
producing equidistant vertices.

Note that applying the {\small\tt\verm{Mesh}} constructor with {\small\tt\textcolor{tag}{tag}::join}
to four segments is very different from applying the {\small\tt\verm{Mesh}} constructor with
{\small\tt\textcolor{tag}{tag}::quadrangle} to the same four segments;
see paragraphs \ref{\numb section 2.\numb parag 9} and \ref{\numb section 2.\numb parag 11}.


          %---------------------------------------------%
\section{~~A hemisphere defined by four curved triangles}\label{\numb section 2.\numb parag 6}
          %---------------------------------------------%

Let's look at a surface in $ \mathbb{R}^3 $ :

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 6}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm                                            ]
   \verm{Manifold} \azul{RR3} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{3} );
   \verm{Function} \azul{xyz} = RR3 .build_coordinate_system ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );
   \verm{Function} \azul{x} = xyz [\laranja{0}], \azul{y} = xyz [\laranja{1}], \azul{z} = xyz [\laranja{2}];

   \verm{Manifold} \azul{sphere} = RR3 .implicit ( x*x + y*y + z*z == \laranja{1.} );

   \cinza{// let's mesh half of a sphere}
   \verm{Cell} \azul{E}  ( \textcolor{tag}{tag}::vertex );  x (E) =  \laranja{1.};  y (E) =  \laranja{0.};  z (E) = \laranja{0.};
   \verm{Cell} \azul{N}  ( \textcolor{tag}{tag}::vertex );  x (N) =  \laranja{0.};  y (N) =  \laranja{1.};  z (N) = \laranja{0.};
   \verm{Cell} \azul{W}  ( \textcolor{tag}{tag}::vertex );  x (W) = \laranja{-1.};  y (W) =  \laranja{0.};  z (W) = \laranja{0.};
   \verm{Cell} \azul{S}  ( \textcolor{tag}{tag}::vertex );  x (W) =  \laranja{0.};  y (W) = \laranja{-1.};  z (W) = \laranja{0.};
   \verm{Cell} \azul{up} ( \textcolor{tag}{tag}::vertex );  x (up)=  \laranja{0.};  y (up)=  \laranja{0.};  z (up)= \laranja{1.};

   int \azul{n} = \laranja{15};
   \verm{Mesh} \azul{EN} ( \textcolor{tag}{tag}::segment, E .reverse(), N, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{NW} ( \textcolor{tag}{tag}::segment, N .reverse(), W, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{WS} ( \textcolor{tag}{tag}::segment, W .reverse(), S, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{SE} ( \textcolor{tag}{tag}::segment, S .reverse(), E, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{upE} ( \textcolor{tag}{tag}::segment, up .reverse(), E, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{upN} ( \textcolor{tag}{tag}::segment, up .reverse(), N, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{upW} ( \textcolor{tag}{tag}::segment, up .reverse(), W, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{upS} ( \textcolor{tag}{tag}::segment, up .reverse(), S, \textcolor{tag}{tag}::divided_in, n );

   \cinza{// build four triangles}
   \verm{Mesh} \azul{ENup} ( \textcolor{tag}{tag}::triangle, EN, upN .reverse(), upE );
   \verm{Mesh} \azul{NWup} ( \textcolor{tag}{tag}::triangle, NW, upW .reverse(), upN );
   \verm{Mesh} \azul{WSup} ( \textcolor{tag}{tag}::triangle, WS, upS .reverse(), upW );
   \verm{Mesh} \azul{SEup} ( \textcolor{tag}{tag}::triangle, SE, upE .reverse(), upS );

   \cinza{// and finally join the triangles :}
   \verm{Mesh} \azul{hemisphere} ( \textcolor{tag}{tag}::join, ENup, NWup, WSup, SEup );
\end{Verbatim}

\begin{figure}[ht] \centering
  \psfrag{S}{\small\tt\textcolor{textindraw}{S}}
  \psfrag{W}{\small\tt\textcolor{textindraw}{W}}
  \psfrag{up}{\small\tt\textcolor{textindraw}{up}}
  \includegraphics[width=95mm]{hemisphere}
  \caption{A hemisphere obtained by {\small\tt join}ing four triangles}
\end{figure}


Again, when we define individual points {\small\tt E}, {\small\tt N}, {\small\tt W},
{\small\tt S} and {\small\tt up} we must be careful to provide coordinates on the
{\small\tt sphere} (or {\small\tt project} them explicitly as shown in paragraph
\ref{\numb section 2.\numb parag 7}).
In contrast, the {\small\tt\verm{Mesh}} constructors with {\small\tt\textcolor{tag}{tag}::segment},
{\small\tt\textcolor{tag}{tag}::quadrangle} and {\small\tt\textcolor{tag}{tag}::triangle}
build points in the surrounding space ($ \mathbb{R}^2 $ or $ \mathbb{R}^3 $) and
then project them onto the current manifold without the user's assistance (paragraph
\ref{\numb section 8.\numb parag 1} describes this projection operation).
As a side effect, within each triangle ({\small\tt ENup}, {\small\tt NWup} and so forth),
the distribution of the vertices is not perfectly uniform.

Note that, when we build the segments {\small\tt WS}, {\small\tt upS} and so on,
we know that those segments will be (polygonal approximations of) arcs of circle on the sphere.
This is so due to the particular geometry of our manifold (we know that the projection of
a straight line segment on the sphere is an arc of circle of radius equal to the radius of
the sphere); the shape of such segments is less clear in other examples
(like the one in paragraph \ref{\numb section 2.\numb parag 7}).

Section \ref{\numb section 3} shows other ways of meshing a surface.


          %----------------------%
\section{~~A more complex surface}\label{\numb section 2.\numb parag 7}
          %----------------------%

If the surface is more ``bumpy'',
% since the projection operation doesn't work well for points far from the manifold,
we must use smaller patches in order to get a mesh of good quality.

Below we use twelve rectangles to get a bumpy hemisphere.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 7}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} nut = RR3 .implicit ( x*x + y*y + z*z + \laranja{1.5}*x*y*z == \laranja{1.} );

   \cinza{// let's mesh a hemisphere (much deformed)}
   \verm{Cell} \azul{S} ( \textcolor{tag}{tag}::vertex );   x (S)  =  \laranja{0.};  y (S)  = \laranja{-1.};  z (S)  =  \laranja{0.};
   \verm{Cell} \azul{E} ( \textcolor{tag}{tag}::vertex );   x (E)  =  \laranja{1.};  y (E)  =  \laranja{0.};  z (E)  =  \laranja{0.};
   \verm{Cell} \azul{N} ( \textcolor{tag}{tag}::vertex );   x (N)  =  \laranja{0.};  y (N)  =  \laranja{1.};  z (N)  =  \laranja{0.};
   \verm{Cell} \azul{W} ( \textcolor{tag}{tag}::vertex );   x (W)  = \laranja{-1.};  y (W)  =  \laranja{0.};  z (W)  =  \laranja{0.};
   \verm{Cell} \azul{up} ( \textcolor{tag}{tag}::vertex );  x (up) =  \laranja{0.};  y (up) =  \laranja{0.};  z (up) =  \laranja{1.};
   \cinza{// no need to project these}
   \verm{Cell} \azul{mSW} ( \textcolor{tag}{tag}::vertex );  x (mSW) = \laranja{-1.};   y (mSW) = \laranja{-1.};   z (mSW) = \laranja{0.};
   nut .project ( mSW );  \cinza{// midway between S and W}
   \verm{Cell} \azul{mSup}  ( \textcolor{tag}{tag}::vertex );  x (mSup) =  \laranja{0.};   y (mSup) = \laranja{-1.};   z (mSup) = \laranja{1.};
   nut .project ( mSup );  \cinza{// midway between S and up}
   \verm{Cell} \azul{mSWup} ( \textcolor{tag}{tag}::vertex );  x (mSWup) = \laranja{-1.};  y (mSWup) = \laranja{-1.};  z (mSWup) = \laranja{1.};
   nut .project ( mSWup );  \cinza{// somewhere between S, W and up}
   \cinza{// ... and so forth ...}

   \cinza{// now build segments :}
   int \azul{n} = \laranja{10};
   \verm{Mesh} \azul{W_mSW}  ( \textcolor{tag}{tag}::segment, W .reverse(), mSW,  \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{W_mWup} ( \textcolor{tag}{tag}::segment, W .reverse(), mWup, \textcolor{tag}{tag}::divided_in, n );
   \cinza{// ... and so forth ...}

   \cinza{// now the twelve rectangles :}
   \verm{Mesh} \azul{rect_W_SW}  ( \textcolor{tag}{tag}::quadrangle,
      mSW_mSWup, mWup_mSWup .reverse(), W_mWup .reverse(), W_mSW );
   \verm{Mesh} \azul{rect_S_SW}  ( \textcolor{tag}{tag}::quadrangle,
      mSup_mSWup, mSW_mSWup .reverse(), S_mSW .reverse(), S_mSup );
   \verm{Mesh} \azul{rect_up_SW} ( \textcolor{tag}{tag}::quadrangle,
      mWup_mSWup, mSup_mSWup .reverse(), up_mSup .reverse(), up_mWup );
   \cinza{// ... and so forth ...}

   \cinza{// and finally join the rectangles :}
   \verm{Mesh} \azul{hemisphere} ( \textcolor{tag}{tag}::join,
      \{ rect_E_NE, rect_E_SE, rect_S_SE, rect_S_SW, rect_W_SW, rect_W_NW,
        rect_N_NE, rect_N_NW, rect_up_SE, rect_up_SW, rect_up_NE, rect_up_NW \} );
\end{Verbatim}

\begin{figure}[ht] \centering
  \psfrag{S}{\small\tt\textcolor{textindraw}{S}}
  \psfrag{W}{\small\tt\textcolor{textindraw}{W}}
  \psfrag{mWS}{\small\tt\textcolor{textindraw}{mWS}}
  \psfrag{mSE}{\small\tt\textcolor{textindraw}{mSE}}
  \psfrag{mWup}{\small\tt\textcolor{textindraw}{mWup}}
  \psfrag{mSup}{\small\tt\textcolor{textindraw}{mSup}}
  \psfrag{mSEup}{\small\tt\textcolor{textindraw}{mSEup}}
  \psfrag{up}{\small\tt\textcolor{textindraw}{up}}
  \psfrag{mWSup}{\small\tt\textcolor{textindraw}{mWSup}}
  \includegraphics[width=90mm]{hemisphere-2}
  \caption{Here we have {\small\tt join}ed twelve rectangles}
  \label{\numb section 2.\numb fig 7}
\end{figure}

Note how we use a version of the {\small\tt\verm{Mesh}} constructor with
{\small\tt\textcolor{tag}{tag}::join} taking as argument a vector of {\small\tt \verm{Mesh}}es;
the same constructor is used in paragraph \ref{\numb section 9.\numb parag 2}.

Unlike in paragraph \ref{\numb section 2.\numb parag 6}, here we do not control the
exact shape of the segments {\small\tt S\_\,mSW}, {\small\tt S\_\,mSup} and so on.
They are projections of straight line segments onto our surface but since the equation
of the surface is rather complicated we do not know the exact shape of these projections.
Since points like {\small\tt mSW} and {\small\tt mSE} have been placed initially in
{\small\tt RR3} not belonging to the {\small\tt bupmy} manifold and then explicitly
{\small\tt project}ed,
there is no guarantee that they lie in the plane $ z = 0 $ (they probably don't).
We notice an angle between {\small\tt W\_\,mSW} and {\small\tt S\_\,mSW} at {\small\tt mSW}.

Paragraph \ref{\numb section 2.\numb parag 14} shows a way to control the shape of the segments
{\small\tt S\_\,mSW}, {\small\tt S\_\,mSE} and so on.

Section \ref{\numb section 3} shows other ways of meshing a surface.


          %--------%
\section{~~Exercise}\label{\numb section 2.\numb parag 8}
          %--------%

Slightly change the code in paragraph \ref{\numb section 2.\numb parag 7}
in order to obtain the mesh shown in figure \ref{\numb section 2.\numb fig 8}.
(Hint: have a look at paragraph \ref{\numb section 2.\numb parag 3}.)

\begin{figure}[ht] \centering
  \includegraphics[width=85mm]{hemisphere-1}
  \caption{Using triangular cells}
  \label{\numb section 2.\numb fig 8}
\end{figure}


          %-----------------------------%
\section{~~Alternating between manifolds}\label{\numb section 2.\numb parag 9}
          %-----------------------------%

Let's go back to the example in paragraph \ref{\numb section 2.\numb parag 5}.
Suppose we want to mesh the whole disk, not just its boundary.
We can build the boundary of the disk just like in paragraph
\ref{\numb section 2.\numb parag 5}, by placing ourselves in the manifold {\small\tt circle}.
But if we want to subsequently mesh the interior of the disk, we must leave {\small\tt circle}
and switch back to the original {\small\tt RR2} manifold.
Method {\small\tt set\_\,as\_\,working\_\,manifold} allows us to do that.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 9}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} \azul{RR2} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{2} );
   \verm{Function} \azul{xy} = RR2 .build_coordinate_system ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );
   \verm{Function} \azul{x} = xy [\laranja{0}], \azul{y} = xy [\laranja{1}];
   
   \verm{Manifold} \azul{circle} = RR2 .implicit ( x*x + y*y == \laranja{1.} );
   
   \verm{Cell} \azul{N} ( \textcolor{tag}{tag}::vertex );  x (N) =  \laranja{0.};  y (N) =  \laranja{1.};
   \verm{Cell} \azul{W} ( \textcolor{tag}{tag}::vertex );  x (W) = \laranja{-1.};  y (W) =  \laranja{0.};
   \verm{Cell} \azul{S} ( \textcolor{tag}{tag}::vertex );  x (S) =  \laranja{0.};  y (S) = \laranja{-1.};
   \verm{Cell} \azul{E} ( \textcolor{tag}{tag}::vertex );  x (E) =  \laranja{1.};  y (E) =  \laranja{0.};
   \verm{Mesh} \azul{NW} ( \textcolor{tag}{tag}::segment, N .reverse(), W, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Mesh} \azul{WS} ( \textcolor{tag}{tag}::segment, W .reverse(), S, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Mesh} \azul{SE} ( \textcolor{tag}{tag}::segment, S .reverse(), E, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Mesh} \azul{EN} ( \textcolor{tag}{tag}::segment, E .reverse(), N, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   
   RR2 .set_as_working_manifold();
   \verm{Mesh} \azul{disk} ( \textcolor{tag}{tag}::quadrangle, NW, WS, SE, EN );
\end{Verbatim}

\begin{figure}[ht] \centering
  \psfrag{S}{\small\tt\textcolor{textindraw}{S}}
  \psfrag{N}{\small\tt\textcolor{textindraw}{N}}
  \psfrag{E}{\small\tt\textcolor{textindraw}{E}}
  \psfrag{W}{\small\tt\textcolor{textindraw}{W}}
  \includegraphics[width=70mm]{disk}
  \caption{A disk treated as a rectangle}
  \label{\numb section 2.\numb fig 9}
\end{figure}

The mesh (shown in figure \ref{\numb section 2.\numb fig 9}) is of poor quality;
we obtain quadrilaterals having a wide angle near {\small\tt S}, {\small\tt N}, {\small\tt E}
and {\small\tt W}.
Paragraphs \ref{\numb section 3.\numb parag 1} and \ref{\numb section 3.\numb parag 2} show
another way of meshing a disk, having its boundary as starting point.

Each time a {\small\tt\verm{Manifold}} object is created, its constructor sets it as
working manifold; this is why in many cases we don't need to know about method
{\small\tt set\_\,as\_\,working\_\,manifold}.
We need it, however, in cases like the one presented here.


          %--------%
\section{~~Exercise}\label{\numb section 2.\numb parag 10}
          %--------%

Mesh half of a disk by joining three triangular meshes
(see figure \ref{\numb section 2.\numb fig 10}).
Mesh the entire disk by joining six triangular meshes.

\begin{figure}[ht] \centering
  \psfrag{S}{\small\tt\textcolor{textindraw}{S}}
  \psfrag{N}{\small\tt\textcolor{textindraw}{N}}
  \psfrag{E}{\small\tt\textcolor{textindraw}{E}}
  \psfrag{W}{\small\tt\textcolor{textindraw}{W}}
  \includegraphics[width=95mm]{half-disk}
  \caption{Half disk}
  \label{\numb section 2.\numb fig 10}
\end{figure}


          %------------------------------------%
\section{~~Alternating between manifolds, again}\label{\numb section 2.\numb parag 11}
          %------------------------------------%


Here is an example similar to the one in paragraph \ref{\numb section 2.\numb parag 9},
this time with four arcs of hiperbola.

\begin{figure}[ht] \centering
  \psfrag{S}{\small\tt\textcolor{textindraw}{S}}
  \psfrag{N}{\small\tt\textcolor{textindraw}{N}}
  \psfrag{E}{\small\tt\textcolor{textindraw}{E}}
  \psfrag{W}{\small\tt\textcolor{textindraw}{W}}
  \includegraphics[width=80mm]{diamond}
  \caption{A diamond shape}
  \label{\numb section 2.\numb fig 11}
\end{figure}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 11}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} \azul{RR2} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{2} );
   \verm{Function} \azul{xy} = RR2 .build_coordinate_system ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );
   \verm{Function} \azul{x} = xy [\laranja{0}], \azul{y} = xy [\laranja{1}];
   \verm{Cell} \azul{N} ( \textcolor{tag}{tag}::vertex );  x (N) =  \laranja{0.};  y (N) =  \laranja{1.};
   \verm{Cell} \azul{W} ( \textcolor{tag}{tag}::vertex );  x (W) = \laranja{-1.};  y (W) =  \laranja{0.};
   \verm{Cell} \azul{S} ( \textcolor{tag}{tag}::vertex );  x (S) =  \laranja{0.};  y (S) = \laranja{-1.};
   \verm{Cell} \azul{E} ( \textcolor{tag}{tag}::vertex );  x (E) =  \laranja{1.};  y (E) =  \laranja{0.};
   \verm{Manifold} \azul{first_arc}  = RR2 .implicit ( x*y + x - y == \laranja{-1.} );
   \verm{Mesh} \azul{NW} ( \textcolor{tag}{tag}::segment, N .reverse(), W, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Manifold} \azul{second_arc} = RR2 .implicit ( x*y - x - y ==  \laranja{1.} );
   \verm{Mesh} \azul{WS} ( \textcolor{tag}{tag}::segment, W .reverse(), S, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Manifold} \azul{third_arc}  = RR2 .implicit ( x*y - x + y == \laranja{-1.} );
   \verm{Mesh} \azul{SE} ( \textcolor{tag}{tag}::segment, S .reverse(), E, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Manifold} \azul{fourth_arc} = RR2 .implicit ( x*y + x + y ==  \laranja{1.} );
   \verm{Mesh} \azul{EN} ( \textcolor{tag}{tag}::segment, E .reverse(), N, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   
   RR2 .set_as_working_manifold();
   \verm{Mesh} \azul{diamond} ( \textcolor{tag}{tag}::quadrangle, NW, WS, SE, EN );
\end{Verbatim}

Paragraph \ref{\numb section 3.\numb parag 17} shows another way of meshing the same domain.
\vfil\eject


          %----------------%
\section{~~An organic shape}\label{\numb section 2.\numb parag 12}
          %----------------%

This paragraph describes a surface meant to mimic the shape of a physalis fruit.

%\begin{figure}[h!]\centering
%  \includegraphics[width=85mm]{empty}
%  \caption{Dry physalis, with fruit inside}\label{\numb section 2.\numb fig 12}
%\end{figure}

\begin{figure}[ht]\centering
%\vskip -3mm
\if\production 1
\centerline{\includegraphics[width=65mm]{dry-physalis}}
\else
\psfrag{photo}{[photo of a physalis]}
\centerline{\includegraphics[width=75mm]{fake-physalis}}
\fi
  \caption{Dry physalis, with fruit inside}\label{\numb section 2.\numb fig 12}
\end{figure}
%\vfil\eject

We begin by defining a revolution surface in $ \mathbb{R}^3 $ :

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 12}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Function} \azul{r2} = x*x + y*y + z*z;
   const double \azul{pi} = \laranja{3.1415926536};
   \verm{Manifold} \azul{apple} = RR3 .implicit ( \verm{power}(r2,\laranja{0.5}) * \verm{sin}(r2-pi/\laranja{6.}) == z );
\end{Verbatim}

This surface has the shape shown in figure \ref{\numb section 2.\numb fig 13},
which does not resemble a physalis fruit.

\begin{figure}[ht] \centering
  \includegraphics[width=55mm]{fisalis-manif}
  \caption{A compact manifold resembling an apple}
  \label{\numb section 2.\numb fig 13}
\end{figure}

Instead of meshing the {\small\tt apple} surface, we just build eight curves immersed in it
(each curve joins {\small\tt A} to {\small\tt D} and is made of three shorter curves) :

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 12}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  x (A) = \laranja{0.};  y (A) = \laranja{0.};  z (A) = std::sqrt ( \laranja{2.}*pi/\laranja{3.} );
   \verm{Cell} \azul{B1} ( \textcolor{tag}{tag}::vertex );  x (B1) = \laranja{1.};  y (B1) = \laranja{0.};  z (B1) = \laranja{1.};
   \verm{Cell} \azul{C1} ( \textcolor{tag}{tag}::vertex );  x (C1) = \laranja{1.};  y (C1) = \laranja{0.};  z (C1) = \laranja{0.};
   apple .project (B1);  apple .project (C1);
   \verm{Cell} \azul{D} ( \textcolor{tag}{tag}::vertex );  x (D) = \laranja{0.};  y (D) = \laranja{0.};  z (D) = \laranja{0.};
   \verm{Mesh} \azul{AB1} ( \textcolor{tag}{tag}::segment, A .reverse(), B1, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Mesh} \azul{B1C1} ( \textcolor{tag}{tag}::segment, B1 .reverse(), C1, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Mesh} \azul{C1D} ( \textcolor{tag}{tag}::segment, C1 .reverse(), D, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \cinza{// and so on ...}
\end{Verbatim}

Then we switch back to {\small\tt RR3} (thus leaving the {\small\tt apple} manifold) and build
transversal segments, as well as triangular and quadrangular patches :

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 12}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   RR3 .set_as_working_manifold();
   \verm{Mesh} \azul{B1B2} ( \textcolor{tag}{tag}::segment, B1 .reverse(), B2, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \verm{Mesh} \azul{B2B3} ( \textcolor{tag}{tag}::segment, B2 .reverse(), B3, \textcolor{tag}{tag}::divided_in, \laranja{10} );
   \cinza{// and many other segments ...}
   \verm{Mesh} \azul{AB1B2} ( \textcolor{tag}{tag}::triangle, AB1, B1B2, AB2 .reverse() );
   \verm{Mesh} \azul{AB2B3} ( \textcolor{tag}{tag}::triangle, AB2, B2B3, AB3 .reverse() );
   \cinza{// and other triangular patches ...}
   \verm{Mesh} \azul{B1C1C2B2} ( \textcolor{tag}{tag}::quadrangle, B1C1, C1C2, B2C2 .reverse(), B1B2 .reverse(),
                   \textcolor{tag}{tag}::with_triangles                                           );
   \verm{Mesh} \azul{B2C2C3B3} ( \textcolor{tag}{tag}::quadrangle, B2C2, C2C3, B3C3 .reverse(), B2B3 .reverse(),
                   \textcolor{tag}{tag}::with_triangles                                           );
   \cinza{// and other quadrangular patches ...}   
\end{Verbatim}

We then join all patches :
\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 12}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Mesh} \azul{sect1} ( \textcolor{tag}{tag}::join, AB1B2, B1C1C2B2, C1DC2 );
   \verm{Mesh} \azul{sect2} ( \textcolor{tag}{tag}::join, AB2B3, B2C2C3B3, C2DC3 );
   \cinza{// more sectors ...}
   std::vector < \verm{Mesh} > lm \{ sect1, sect2, sect3, sect4, sect5, sect6, sect7, sect8 \};
   \verm{Mesh} \azul{fisalis} ( \textcolor{tag}{tag}::join, lm ); 
\end{Verbatim}

\begin{figure}[ht] \centering
  \includegraphics[width=45mm]{fisalis-round}
  \caption{Not yet a physalis}
  \label{\numb section 2.\numb fig 14}
\end{figure}

This shape is still not satisfactory, so we apply a deformation in $ \mathbb{R}^3 $ in order to
get a sharper tip.
The {\small\tt apple} manifold is no longer relevant.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 12}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Mesh}::Iterator \azul{it} = fisalis .iterator ( \textcolor{tag}{tag}::over_vertices );
   for ( it .reset(); it .in_range(); it++ )
   \{  \verm{Cell} \azul{P} = *it;
      x(P) *= \laranja{0.8};  y(P) *= \laranja{0.8};
      if ( z(P) > \laranja{1.3} )
      \{  x(P) = x(P) / ( \laranja{1.} + \laranja{300.} * std::pow ( z(P) - \laranja{1.3}, \laranja{3.} ) );
         y(P) = y(P) / ( \laranja{1.} + \laranja{300.} * std::pow ( z(P) - \laranja{1.3}, \laranja{3.} ) );
         z(P) = z(P) * ( \laranja{1.} + \laranja{10.} * ( z(P) - \laranja{1.3} ) * ( z(P) - \laranja{1.3} ) );  \}
      if ( z(P) > \laranja{0.} ) z(P) *= \laranja{0.8};                                        \}
\end{Verbatim}

Paragraph \ref{\numb section 9.\numb parag 3} explains the notion of an iterator over cells.

We add a sequence of baricenter operations for smoothening the shape.
Note that each baricenter operation is relative to a sector and it applies only to inner
vertices, so the boundary of the sector is not changed.
Thus, the eight rims defined in the beginning are kept unchanged.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 12}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   std::vector < \verm{Mesh} > ::iterator \azul{it1};
   for ( it1 = lm .begin(); it1 != lm .end(); it1++ )
   \{  \verm{Mesh} \azul{sect} = *it1;
      \verm{Mesh}::Iterator \azul{it2} = sect .iterator ( \textcolor{tag}{tag}::over_vertices );
      for ( int \azul{i} = \laranja{1}; i < \laranja{20}; i++ )
      for ( it2 .reset(); it2 .in_range(); it2++ )
      \{  \verm{Cell} \azul{ver} = *it2;
         if ( ver .is_inner_to ( sect ) ) sect .baricenter ( ver );  \}  \}
\end{Verbatim}

And we are happy with the final result, shown in figure \ref{\numb section 2.\numb fig 15}.

\begin{figure}[ht] \centering
  \includegraphics[width=60mm]{fisalis}
  \caption{Meshing a chinese lantern}
  \label{\numb section 2.\numb fig 15}
\end{figure}

An animation related to this example is available at\hfil\break
{\small\tt http://manifem.rd.ciencias.ulisboa.pt/apple-to-physalis.gif}


          %-----------------------------------%
\section{~~A manifold defined by two equations}\label{\numb section 2.\numb parag 13}
          %-----------------------------------%

We can define a one-dimensional submanifold of $ \mathbb{R}^3 $ by two implicit equations :
\medskip

\begin{figure}[ht] \centering
  \psfrag{S}{\small\tt\textcolor{textindraw}{S}}
  \psfrag{N}{\small\tt\textcolor{textindraw}{N}}
  \psfrag{E}{\small\tt\textcolor{textindraw}{E}}
  \psfrag{W}{\small\tt\textcolor{textindraw}{W}}
  \includegraphics[width=75mm]{circle-3d}
  \caption{One-dimensional mesh in $ {\mathbb R}^3 $}
  \label{\numb section 2.\numb fig 16}
\end{figure}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 13}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} \azul{RR3} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{3} );
   \verm{Function} \azul{xyz} = RR3 .build_coordinate_system ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );
   \verm{Function} \azul{x} = xyz [\laranja{0}], \azul{y} = xyz [\laranja{1}], \azul{z} = xyz [\laranja{2}];
   \verm{Manifold} \azul{circle_manifold} = RR3 .implicit ( x*x + y*y == \laranja{1.}, x*y == \laranja{4.}*z );

   \verm{Cell} \azul{S} ( \textcolor{tag}{tag}::vertex );  x (S) =  \laranja{0.};  y (S) = \laranja{-1.};  z (S) = \laranja{0.};
   \verm{Cell} \azul{E} ( \textcolor{tag}{tag}::vertex );  x (E) =  \laranja{1.};  y (E) =  \laranja{0.};  z (E) = \laranja{0.};
   \verm{Cell} \azul{N} ( \textcolor{tag}{tag}::vertex );  x (N) =  \laranja{0.};  y (N) =  \laranja{1.};  z (N) = \laranja{0.};
   \verm{Cell} \azul{W} ( \textcolor{tag}{tag}::vertex );  x (W) = \laranja{-1.};  y (W) =  \laranja{0.};  z (W) = \laranja{0.};
   \cinza{// these four points already belong to 'circle_manifold', no projection needed}

   \verm{Mesh} \azul{SE} ( \textcolor{tag}{tag}::segment, S .reverse(), E, \textcolor{tag}{tag}::divided_in, \laranja{5} );
   \verm{Mesh} \azul{EN} ( \textcolor{tag}{tag}::segment, E .reverse(), N, \textcolor{tag}{tag}::divided_in, \laranja{5} );
   \verm{Mesh} \azul{NW} ( \textcolor{tag}{tag}::segment, N .reverse(), W, \textcolor{tag}{tag}::divided_in, \laranja{5} );
   \verm{Mesh} \azul{WS} ( \textcolor{tag}{tag}::segment, W .reverse(), S, \textcolor{tag}{tag}::divided_in, \laranja{5} );

   \verm{Mesh} \azul{circle} ( \textcolor{tag}{tag}::join, SE, EN, NW, WS );
\end{Verbatim}

Paragraph \ref{\numb section 3.\numb parag 4} shows another way of meshing the same loop.


          %------------------------------%
\section{~~A submanifold of a submanifold}\label{\numb section 2.\numb parag 14}
          %------------------------------%

An implicit manifold has submanifolds.
For instance, we can improve the look of the ``bumpy hemisphere'' in paragraph
\ref{\numb section 2.\numb parag 7} by building its base (a circle-like closed curve)
inside a one-dimensional manifold.
For the rest of the surface, we switch back to the two-dimensional manifold {\small\tt nut} :
\medskip

\begin{figure}[ht] \centering
  \includegraphics[width=100mm]{bumpy}
  \caption{A shell}
  \label{\numb section 2.\numb fig 17}
\end{figure}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 14}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} \azul{nut} = RR3 .implicit ( x*x + y*y + z*z + \laranja{1.5}*x*y*z == \laranja{1.} );
   int \azul{n} = \laranja{10};

   \cinza{// first build the base (a closed curve)}
   \verm{Manifold} \azul{base} = nut .implicit ( x*x + \laranja{3.}*z == \laranja{0.} );

   \verm{Cell} \azul{S} ( \textcolor{tag}{tag}::vertex );  x (S) =  \laranja{0.};  y (S) = \laranja{-1.};  z (S) =  \laranja{0.};
   \verm{Cell} \azul{E} ( \textcolor{tag}{tag}::vertex );  x (E) =  \laranja{1.};  y (E) =  \laranja{0.};  z (E) =  \laranja{0.};
   \verm{Cell} \azul{N} ( \textcolor{tag}{tag}::vertex );  x (N) =  \laranja{0.};  y (N) =  \laranja{1.};  z (N) =  \laranja{0.};
   \verm{Cell} \azul{W} ( \textcolor{tag}{tag}::vertex );  x (W) = \laranja{-1.};  y (W) =  \laranja{0.};  z (W) =  \laranja{0.};
   \cinza{// no need to project S and N, they are already on 'base'}
   base .project (E);  base .project (W);
   \verm{Cell} \azul{mSW} ( \textcolor{tag}{tag}::vertex );  x (mSW) = \laranja{-1.};  y (mSW) = \laranja{-1.};  z (mSW) = \laranja{0.};
   base .project ( mSW );  \cinza{// midway between S and W}
   \verm{Cell} \azul{mSE} ( \textcolor{tag}{tag}::vertex );  x (mSE) =  \laranja{1.};  y (mSE) = \laranja{-1.};  z (mSW) = \laranja{0.};
   base .project ( mSE );  \cinza{// midway between S and E}
   \cinza{// define similarly mNE and mNW}

   \cinza{// now build eight segments, forming the base}
   \verm{Mesh} \azul{S_mSW} ( \textcolor{tag}{tag}::segment, S .reverse(), mSW, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{S_mSE} ( \textcolor{tag}{tag}::segment, S .reverse(), mSE, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{E_mSE} ( \textcolor{tag}{tag}::segment, E .reverse(), mSE, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{E_mNE} ( \textcolor{tag}{tag}::segment, E .reverse(), mNE, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{N_mNE} ( \textcolor{tag}{tag}::segment, N .reverse(), mNE, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{N_mNW} ( \textcolor{tag}{tag}::segment, N .reverse(), mNW, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{W_mSW} ( \textcolor{tag}{tag}::segment, W .reverse(), mSW, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{W_mNW} ( \textcolor{tag}{tag}::segment, W .reverse(), mNW, \textcolor{tag}{tag}::divided_in, n );

   \cinza{// we are done with the base, now switch back to 'nut'}
   nut .set_as_working_manifold();
   \cinza{// more points :}
   \verm{Cell} \azul{up} ( \textcolor{tag}{tag}::vertex );  x (up) = \laranja{0.};  y (up) = \laranja{0.};  z (up) = \laranja{1.};
   \cinza{// no need to project 'up', it is already on 'nut'}
   \verm{Cell} \azul{mSup}  ( \textcolor{tag}{tag}::vertex );  x (mSup) = \laranja{0.};  y (mSup) = \laranja{-1.};  z (mSup) = \laranja{1.};
   nut .project ( mSup );  \cinza{// midway between S and up}
   \verm{Cell} \azul{mSWup} ( \textcolor{tag}{tag}::vertex );  x (mSWup) = \laranja{-1.};  y (mSWup) = \laranja{-1.};  z (mSWup) = \laranja{1.};
   nut .project ( mSWup );  \cinza{// somewhere between S, W and up}
   \cinza{// ... and so forth ...}

   \cinza{// more segments :}
   \verm{Mesh} \azul{W_mWup} ( \textcolor{tag}{tag}::segment, W .reverse(), mWup, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{mSW_mSWup} ( \textcolor{tag}{tag}::segment, mSW .reverse(), mSWup, \textcolor{tag}{tag}::divided_in, n );
   \verm{Mesh} \azul{mWup_mSWup} ( \textcolor{tag}{tag}::segment, mWup .reverse(), mSWup, \textcolor{tag}{tag}::divided_in, n );
   \cinza{// ... and so forth ...}
\end{Verbatim}

If we wanted a flat base, we could have defined

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \verm{Manifold} \azul{base} = nut .implicit ( z == \laranja{0.} );
\end{Verbatim}

Paragraph \ref{\numb section 3.\numb parag 9} shows a way to mesh the same surface using
fewer lines of code.


          %-------------------------------%
\section{~~Parametric manifolds -- a curve}\label{\numb section 2.\numb parag 15}
          %-------------------------------%

Paragraphs \ref{\numb section 2.\numb parag 4} -- \ref{\numb section 2.\numb parag 14} describe
manifolds defined through implicit equations, that is, level sets in $ \mathbb{R}^2 $ or
$ \mathbb{R}^3 $.
Another way of defining a submanifold is through a parametrization.
Below is an example.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 15}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \cinza{// at the beginning, we define 'spiral' as a straight line}
   \verm{Manifold} \azul{spiral} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{1} );
   \verm{Function} \azul{t} = spiral .build_coordinate_system ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, 1 );

   \cinza{// now build 'arc_of_spiral' merely as a segment from pi/2 to 5 pi}
   const double \azul{pi} = \laranja{3.1415926536};
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  t (A) = pi/\laranja{2.};
   \verm{Cell} \azul{B} ( \textcolor{tag}{tag}::vertex );  t (B) = \laranja{5.}*pi;

   \verm{Mesh} \azul{arc_of_spiral} ( \textcolor{tag}{tag}::segment, A .reverse(), B, \textcolor{tag}{tag}::divided_in, \laranja{30} );
   \cinza{// not very interesting for now}
   \cinza{// but now define functions x and y as expressions of t :}
   \verm{Function} \azul{x} = t * \verm{cos}(t), \azul{y} = t * \verm{sin}(t);
   \cinza{// and declare them to be the new coordinates}
   \verm{Manifold} \azul{RR2} ( tag::Euclid, \textcolor{tag}{tag}::of_dimension, \laranja{2} );
   RR2 .set_coordinates ( x && y );
   \cinza{// in future statements (e.g. for graphical representation)}
   \cinza{// x and y will be used, not t :}
   arc_of_spiral .draw_ps (\verde{"spiral.eps"});
\end{Verbatim}

\begin{figure}[ht] \centering
  \psfrag{A}{\small\tt\textcolor{textindraw}{A}}
  \psfrag{B}{\small\tt\textcolor{textindraw}{B}}
  \includegraphics[width=60mm]{spiral}
  \caption{One-dimensional mesh in $ {\mathbb R}^2 $}
\end{figure}

The operator {\small\tt \&\&} joins two functions into one vector-valued function.

Note that, when defining points {\small\tt A} and {\small\tt B}, we only set the value of
{\small\tt t}.
Functions {\small\tt x} and {\small\tt y} are defined later, as arithmetic expressions in terms of
{\small\tt t}; their values will be computed ``on-the-fly'' when needed.
%A parametric manifold has attached to it a function called ``parameter'' and another one called
%``coordinate''.
%Both may be vector functions (may have serveral components).
%The ``coordinates'' are used, for instance, for graphical representation.
%The ``parameter'' or ``parameters'' are used, for instance, for interpolation.
%The {\small\tt\verm{Mesh}} constructors with {\small\tt\textcolor{tag}{tag}::segment},
%{\small\tt\textcolor{tag}{tag}::quadrangle} or {\small\tt\textcolor{tag}{tag}::triangle}
% build new points and define their position in the manifold by
%interpolating the parameters, not the coordinates.
%Unlike for implicit manifolds, no projection is necessary.
In the drawing above, we note that the generated points are not equidistant in the sense of the
Euclidian distance in $ \mathbb{R}^2 $.
They correspond to values of {\small\tt t} which are uniformly distributed between
$ \pi/2 $ (at {\small\tt A}) and $ 5\pi $ (at {\small\tt B}).

The approach described above has the disadvantage that, if we want to subsequently change the
distribution of nodes along the {\small\tt arc\_\,of\_\,spiral}, we must switch back to the original
{\small\tt t} coordinate.

Paragraph \ref{\numb section 3.\numb parag 5} shows another way of meshing a curve,
producing equidistant vertices.


          %----------------%
\section{~~Closing a circle}\label{\numb section 2.\numb parag 16}
          %----------------%

In the approach of paragraph \ref{\numb section 2.\numb parag 15}, it is possible but cumbersome to
build a closed curve :

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 16}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} \azul{circle_manif} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{1} );
   \verm{Function} \azul{t} = circle_manif .build_coordinate_system
      ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );

   \cinza{// build 'circle' merely as a segment from 0 to 1.9 pi}
   const double \azul{pi} = \laranja{3.1415926536};
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  t(A) =  \laranja{0.};
   \verm{Cell} \azul{B} ( \textcolor{tag}{tag}::vertex );  t(B) =  \laranja{1.9}*pi;
   \verm{Mesh} \azul{incomplete_circle} ( \textcolor{tag}{tag}::segment, A .reverse(), B, \textcolor{tag}{tag}::divided_in, \laranja{19} );

   \cinza{// now close the curve in a not very elegant manner}
   \verm{Mesh} \azul{small_piece} ( \textcolor{tag}{tag}::segment, B .reverse(), A, \textcolor{tag}{tag}::divided_in, \laranja{1} );
   \verm{Mesh} \azul{circle} ( \textcolor{tag}{tag}::join, incomplete_circle, small_piece );
   \cinza{// define new coordinates x and y as expressions of t :}
   \verm{Function} \azul{x} = \verm{cos}(t), \azul{y} = \verm{sin}(t);
   \verm{Manifold} \azul{RR2} ( tag::Euclid, \textcolor{tag}{tag}::of_dimension, \laranja{2} );
   RR2 .set_coordinates ( x && y );

   \cinza{// in future statements (e.g. for graphical representation)}
   \cinza{// x and y will be used, not t :}
   circle .draw_ps (\verde{"circle.eps"});
\end{Verbatim}

Paragraph \ref{\numb section 7.\numb parag 2} shows a more elegant way to close a curve in itself.

On the other hand, if we only want a visual illusion of a closed circle, we may use the code below.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \verm{Manifold} \azul{circle_manif} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{1} );
   \verm{Function} \azul{t} = circle_manif .build_coordinate_system
      ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );

   \cinza{// build 'circle' merely as a segment from 0 to 2 pi}
   const double \azul{pi} = \laranja{3.1415926536};
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  t (A) = \laranja{0.};
   \verm{Cell} \azul{B} ( \textcolor{tag}{tag}::vertex );  t (B) = \laranja{2.}*pi;
   \verm{Mesh} \azul{circle} ( \textcolor{tag}{tag}::segment, A .reverse(), B, \textcolor{tag}{tag}::divided_in, \laranja{20} );
   \cinza{// gives the illusion of a closed circle}

   \cinza{// define new coordinates x and y as expressions of t :}
   \verm{Function} \azul{x} = \verm{cos}(t), \azul{y} = \verm{sin}(t);
   \verm{Manifold} \azul{RR2} ( tag::Euclid, \textcolor{tag}{tag}::of_dimension, \laranja{2} );
   RR2 .set_coordinates ( x && y );
\end{Verbatim}


          %---------------------------------%
\section{~~Parametric manifolds -- a surface}\label{\numb section 2.\numb parag 17}
          %---------------------------------%

Here is an example of a parametrized surface :

\begin{figure}[ht] \centering
  \includegraphics[width=105mm]{torus}
  \caption{Incomplete torus}
\end{figure}

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 17}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} \azul{torus} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{2} );
   \verm{Function} \azul{alpha_beta} =
      torus .build_coordinate_system ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );

   \cinza{// extract components of alpha_beta :}
   \verm{Function} \azul{alpha} = alpha_beta [0], \azul{beta} = alpha_beta [1];

   \cinza{// build a rectangle in the alpha-beta plane}
   const double \azul{pi} = \laranja{3.1415926536};
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  alpha (A) = \laranja{0.};       beta (A) = \laranja{0.};
   \verm{Cell} \azul{B} ( \textcolor{tag}{tag}::vertex );  alpha (B) = \laranja{0.};       beta (B) = \laranja{1.9}*pi;
   \verm{Cell} \azul{C} ( \textcolor{tag}{tag}::vertex );  alpha (C) = \laranja{1.95}*pi;  beta (C) = \laranja{1.9}*pi;
   \verm{Cell} \azul{D} ( \textcolor{tag}{tag}::vertex );  alpha (D) = \laranja{1.95}*pi;  beta (D) = \laranja{0.};

   \cinza{// four almost-closed circles :}
   \verm{Mesh} \azul{AB} ( \textcolor{tag}{tag}::segment, A .reverse(), B, \textcolor{tag}{tag}::divided_in, \laranja{19} );
   \verm{Mesh} \azul{BC} ( \textcolor{tag}{tag}::segment, B .reverse(), C, \textcolor{tag}{tag}::divided_in, \laranja{39} );
   \verm{Mesh} \azul{CD} ( \textcolor{tag}{tag}::segment, C .reverse(), D, \textcolor{tag}{tag}::divided_in, \laranja{19} );
   \verm{Mesh} \azul{DA} ( \textcolor{tag}{tag}::segment, D .reverse(), A, \textcolor{tag}{tag}::divided_in, \laranja{39} );
   \verm{Mesh} \azul{ABCD} ( \textcolor{tag}{tag}::rectangle, AB, BC, CD, DA );  \cinza{// an almost-closed torus}
   
   \cinza{// parametrize the torus}
   const double \azul{big_radius} = \laranja{3.}, \azul{small_radius} = \laranja{1.};
   \verm{Function} \azul{x} = ( big_radius + small_radius * \verm{cos}(beta) ) * \verm{cos}(alpha),
            \azul{y} = ( big_radius + small_radius * \verm{cos}(beta) ) * \verm{sin}(alpha),
            \azul{z} = small_radius * \verm{sin}(beta);

   \verm{Manifold} \azul{RR3} ( tag::Euclid, \textcolor{tag}{tag}::of_dimension, \laranja{3} );
   RR3 .set_coordinates ( x && y && z );  \cinza{// forget about alpha and beta}
   \cinza{// in future statements (e.g. for graphical representation)}
   \cinza{// x, y and z will be used, not alpha nor beta :}
   ABCD .export_to_file ( \textcolor{tag}{tag}::msh, \verde{"torus.msh"});
\end{Verbatim}

Closing the torus in the cumbersome manner shown in paragraph
\ref{\numb section 2.\numb parag 16} is possible but not practical.
Paragraph \ref{\numb section 7.\numb parag 5} shows a more elegant solution.

If we only want a visual illusion of a closed surface, we may use the code below

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  alpha (A) = \laranja{0.};     beta (A) = \laranja{0.};
   \verm{Cell} \azul{B} ( \textcolor{tag}{tag}::vertex );  alpha (B) = \laranja{0.};     beta (B) = \laranja{2.}*pi;
   \verm{Cell} \azul{C} ( \textcolor{tag}{tag}::vertex );  alpha (C) = \laranja{2.}*pi;  beta (C) = \laranja{2.}*pi;
   \verm{Cell} \azul{D} ( \textcolor{tag}{tag}::vertex );  alpha (D) = \laranja{2.}*pi;  beta (D) = \laranja{0.};

   \verm{Mesh} \azul{AB} ( \textcolor{tag}{tag}::segment, A .reverse(), B, \textcolor{tag}{tag}::divided_in, \laranja{20} );
   \verm{Mesh} \azul{BC} ( \textcolor{tag}{tag}::segment, B .reverse(), C, \textcolor{tag}{tag}::divided_in, \laranja{40} );
   \verm{Mesh} \azul{CD} ( \textcolor{tag}{tag}::segment, C .reverse(), D, \textcolor{tag}{tag}::divided_in, \laranja{20} );
   \verm{Mesh} \azul{DA} ( \textcolor{tag}{tag}::segment, D .reverse(), A, \textcolor{tag}{tag}::divided_in, \laranja{40} );
   \cinza{// AB, BC, CD and DA look like closed circles}

   \verm{Mesh} \azul{ABCD} ( \textcolor{tag}{tag}::rectangle, AB, BC, CD, DA );
   \cinza{// ABCD gives the illusion of a closed torus}
\end{Verbatim}


          %-----------------------------------------%
\section{~~Starting with a high-dimensional manifold}\label{\numb section 2.\numb parag 18}
          %-----------------------------------------%

Instead of starting with a manifold having only the parameter(s), we may start with a
high-dimensional manifold containing both the geometric coordinates and the parameter(s),
then define the parametrization through equation(s).
% The advantage of this approach is that we can later shwitch on and off a constraint,
% thus switching between meshes of different dimensions.
There is a disadvantage however, regarding performance : {\maniFEM} will reserve,
for each vertex, space in the computer's memory for five {\small\tt double} values.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=parag-\ref{\numb section 2.\numb parag 18}.cpp,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm]
   \verm{Manifold} \azul{RR5} ( \textcolor{tag}{tag}::Euclid, \textcolor{tag}{tag}::of_dim, \laranja{5} );
   \verm{Function} \azul{xyzab} = RR5 .build_coordinate_system ( \textcolor{tag}{tag}::Lagrange, \textcolor{tag}{tag}::of_degree, \laranja{1} );

   \cinza{// extract components of xyzab :}
   \verm{Function} \azul{x} = xyzab [\laranja{0}], \azul{y} = xyzab [\laranja{1}], \azul{z} = xyzab [\laranja{2}],
             \azul{alpha} = xyzab [\laranja{3}], \azul{beta} = xyzab [\laranja{4}];

   \cinza{// define a torus as a submanifold of RR5 :}
   const double \azul{big_radius} = \laranja{3}, \azul{small_radius} = \laranja{1};
   \verm{Manifold} \azul{torus} = RR5 .parametric
      ( x == ( big_radius + small_radius * \verm{cos}(beta) ) * \verm{cos}(alpha),
        y == ( big_radius + small_radius * \verm{cos}(beta) ) * \verm{sin}(alpha),
        z == small_radius * \verm{sin}(beta)                                );
        
   \cinza{// define four corners :}
   const double \azul{pi} = \laranja{3.1415926536};
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  alpha (A) = \laranja{0.};       beta (A) = \laranja{0.};
   torus .project (A);
   \verm{Cell} \azul{B} ( \textcolor{tag}{tag}::vertex );  alpha (B) = \laranja{0.};       beta (B) = \laranja{1.9}*pi;
   torus .project (B);
   \verm{Cell} \azul{C} ( \textcolor{tag}{tag}::vertex );  alpha (C) = \laranja{1.95}*pi;  beta (C) = \laranja{1.9}*pi;
   torus .project (C);
   \verm{Cell} \azul{D} ( \textcolor{tag}{tag}::vertex );  alpha (D) = \laranja{1.95}*pi;  beta (D) = \laranja{0.};
   torus .project (D);

   \cinza{// four almost-closed circles :}
   \verm{Mesh} \azul{AB} ( \textcolor{tag}{tag}::segment, A .reverse(), B, \textcolor{tag}{tag}::divided_in, \laranja{19} );
   \verm{Mesh} \azul{BC} ( \textcolor{tag}{tag}::segment, B .reverse(), C, \textcolor{tag}{tag}::divided_in, \laranja{39} );
   \verm{Mesh} \azul{CD} ( \textcolor{tag}{tag}::segment, C .reverse(), D, \textcolor{tag}{tag}::divided_in, \laranja{19} );
   \verm{Mesh} \azul{DA} ( \textcolor{tag}{tag}::segment, D .reverse(), A, \textcolor{tag}{tag}::divided_in, \laranja{39} );

   \cinza{// build a rectangle}
   \verm{Mesh} \azul{ABCD} ( \textcolor{tag}{tag}::rectangle, AB, BC, CD, DA );  \cinza{// an almost-closed torus}

   \verm{Manifold} \azul{RR3} ( tag::Euclid, \textcolor{tag}{tag}::of_dimension, \laranja{3} );
   RR3 .set_coordinates ( x && y && z );  \cinza{// forget about alpha and beta}

   \cinza{// in future statements (e.g. for graphical representation)}
   \cinza{// x, y and z will be used, not alpha nor beta :}
   ABCD .export_to_file ( \textcolor{tag}{tag}::msh, \verde{"torus.msh"});
\end{Verbatim}

The {\small\tt\verm{Manifold}::parametric} method is similar to {\small\tt\verm{Manifold}::implicit},
presented in paragraphs \ref{\numb section 2.\numb parag 4} --
\ref{\numb section 2.\numb parag 14}.
The only difference is that by using {\small\tt parametric} we declare an explicit dependence%
\footnote {Perhaps {\small\tt explicit} would be a better name than {\small\tt parametric};
unfortunately, that word is reserved in {\small\tt C++}.}
of the coordinates (here, {\small\tt x}, {\small\tt y} and {\small\tt z}) upon the parameters
(here, {\small\tt alpha} and {\small\tt beta}).
This endows the manifold {\small\tt torus} with a different projection operator.
The projection of a vertex from {\small\tt RR5} onto {\small\tt torus} is done by merely updating
the values of {\small\tt x}, {\small\tt y} and {\small\tt z}, while keeping {\small\tt alpha} and
{\small\tt beta} constant.
