
          %-----------------%
\chapter{~~Technical details}\label{\numb section 11}
          %-----------------%

Sections \ref{\numb section 11} and \ref{\numb section 12} are meant for those intereseted
in developing and extending \maniFEM.
Of course the ultimate documentation is the source code; these sections can be used as
a guide through the source code.


          %--------------------------%
\section{~~Namespaces and class names}\label{\numb section 11.\numb parag 1}
          %--------------------------%

All names in {\maniFEM} are wrapped into the namespace {\small\tt\verm{maniFEM}}.
We recommend {\small\tt using} {\small\tt namespace} {\small\tt\verm{maniFEM}} in your code,
otherwise the text will become cumbersome.
For instance, you will have to write {\small\tt\verm{maniFEM}::CellIterator} instead of
{\small\tt\verm{CellIterator}}, and so on.
We are {\small\tt using} {\small\tt namespace} {\small\tt\verm{maniFEM}} in the examples
of this manual.

As a general rule, namespaces and class names are written with capital initial
letter$\;$:
{\small\tt\verm{Cell}}, {\small\tt\verm{Mesh}}, {\small\tt\verm{Integrator}},
{\small\tt\verm{FiniteElement}}, {\small\tt\verm{VariationalFormulation}}.
Namespace {\small\tt\textcolor{tag}{tag}} (see paragraph \ref{\numb section 11.\numb parag 3})
is an exception to the above rule.
Namespace {\small\tt\verm{maniFEM}} itself is also an exception, for merely aestetic reasons.

In \maniFEM, there are no {\small\tt private} or {\small\tt protected} class members or methods.
Everything is {\small\tt public};
the user can make use of any class member if he or she so chooses.
This can be considered poor design; we endorse this criticism with no further comments.

However, some class members and methods are intended to be used by the final user,
while others are used in the internal implementation of the former.
Classes \hbox{intended} for basic usage are directly exposed in {\small\tt namespace}
{\small\tt\verm{maniFEM}}, for instance
{\small\tt\verm{Cell}}, {\small\tt\verm{Mesh}}, {\small\tt\verm{CellIterator}},
{\small\tt\verm{Function}}, {\small\tt\verm{Manifold}}, {\small\tt\verm{VariationalFormulation}},
{\small\tt\verm{Integrator}}, {\small\tt\verm{FiniteElement}}.
Classes not intended for the final user (at least not for the basic usage of \maniFEM)
have been hidden inside the above mentioned names, e.g. {\small\tt\verm{Mesh}::Positive},
\ {\small\tt\verm{CellIterator}::Over::SegsOfPosLoop::Positive},
\hbox{\small\tt\verm{Function}::CoupledWithField::Scalar}.
Also, in the source code there are comments like

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \cinza{// do not use directly, let [some other method] do the job}
\end{Verbatim}

In an effort not to expose too many names in the {\small\tt\verm{maniFEM}} namespace, we have
used the namespace {\small\tt\textcolor{tag}{tag}::Util} to keep names which did not fit elsewhere.
We have also used anonymous namespaces in order to hide names of functions which are
only used in one source file.

In the {\small\tt namespace} {\small\tt\verm{maniFEM}} there are also many overloaded functions.
Because they take arguments of specific type, they will not clash with names defined
by the user or by other libraries.
Examples are : {\small\tt\verm{smooth\_\,min}}, {\small\tt\verm{power}}, {\small\tt\verm{abs}},
{\small\tt\verm{sin}}.


          %-------------%
\section{~~Code coloring}\label{\numb section 11.\numb parag 2}
          %-------------%

Throughout this manual, example {\tt C++} code is coloured according to the following
conventions.

Class names directly exposed in {\small\tt namespace} {\small\tt\verm{maniFEM}} are shown in
\verm{blue} : {\small\tt\verm{Cell}}, {\small\tt\verm{Mesh}}, {\small\tt\verm{CellIterator}},
{\small\tt\verm{Function}}, {\small\tt\verm{Manifold}},
{\small\tt\verm{VariationalFormulation}}, {\small\tt\verm{Integrator}},
{\small\tt\verm{FiniteElement}}, the rarely needed {\small\tt\verm{Field}} and
the even more rarely needed {\small\tt\verm{MeshIterator}} and {\small\tt\verm{MetricTree}}.
There are also functions like {\small\tt\verm{smooth\_\,min}} and also overloaded versions
of common functions like {\small\tt\verm{power}}, {\small\tt\verm{sin}}, {\small\tt\verm{cos}}.
The word {\small\tt \textcolor{tag}{tag}} deserves a special treatment.
On one hand, it is directly exposed, on the other hand, we want it to be discrete.
That's why we have chosen a \textcolor{tag}{blue grey} for {\small\tt \textcolor{tag}{tag}}\hskip0.8pt s.

Newly declared objects are shown in \azul{purple}.

Numeric constants are \laranja{orange} (work in progress).

Comments are \cinza{grey}.

Strings are \verde{dark green}.


          %----%
\section{~~Tags}\label{\numb section 11.\numb parag 3}
          %----%

We use extensively {\small\tt\textcolor{tag}{tag}}\hskip0.8pt s.
These are {\tt C++} structures gathered in the {\small\tt namespace}
{\small\tt \textcolor{tag}{tag}}.
Most of them contain no data; only their type is useful, at compile time.

A {\small\tt\textcolor{tag}{tag}} is used to clearly distinguish between functions with
the same name (overloaded functions).
For instance, in the code excerpt below five {\small\tt\verm{CellIterator}}s are defined
by means of different (overloaded) methods having the same name
{\small\tt\verm{Mesh}::iterator});
the iterators behave very differently (see paragraphs \ref{\numb section 9.\numb parag 3} and
\ref{\numb section 9.\numb parag 4}).

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \cinza{// 'chain' is a one-dimensional Mesh}
   \verm{CellIterator} \azul{it1} = chain .iterator ( \textcolor{tag}{tag}::over_vertices );
   \verm{CellIterator} \azul{it2} = chain .iterator ( \textcolor{tag}{tag}::over_vertices, \textcolor{tag}{tag}::backwards );
   \verm{CellIterator} \azul{it3} = chain .iterator ( \textcolor{tag}{tag}::over_segments );
   \verm{CellIterator} \azul{it4} = chain .iterator ( \textcolor{tag}{tag}::over_segments, \textcolor{tag}{tag}::backwards );
   \verm{CellIterator} \azul{it5} = chain .iterator ( \textcolor{tag}{tag}::over_segments, \textcolor{tag}{tag}::force_positive );
\end{Verbatim}

The above could be achieved by giving longer names to the functions, but we believe
{\small\tt\textcolor{tag}{tag}}\hskip0.8pt s make the code more readable.
Besides that, in the case of constructors, we do not have the choice of the name of the function
(a constructor has the same name as its class).
{\ManiFEM} uses {\small\tt\textcolor{tag}{tag}}\hskip0.8pt s extensively for constructors, e.g.
\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   \verm{Cell} \azul{A} ( \textcolor{tag}{tag}::vertex );  \verm{Cell} \azul{B} ( \textcolor{tag}{tag}::vertex );
   \verm{Mesh} \azul{AB} ( \textcolor{tag}{tag}::segment, A .reverse(), B, \textcolor{tag}{tag}::divided_in, 10 );
\end{Verbatim}

In \maniFEM, namespaces and class names begin with capital letter
(see paragraph \ref{\numb section 11.\numb parag 1}).
The namespace {\small\tt\textcolor{tag}{tag}} (or {\small\tt\verm{maniFEM}::tag} if you are not
{\small\tt using} {\small\tt namespace} {\small\tt\verm{maniFEM}}) is an exception
to the above rule.
We prefer its name to have only lower case letters because we want it to be
discrete. For instance, if we wrote {\small\tt\textcolor{tag}{Tag}::divided\_\,in},
the reader's eye would catch {\small\tt\textcolor{tag}{Tag}} much before
{\small\tt divided\_\,in};
thus, {\small\tt\textcolor{tag}{tag}::divided\_\,in} is more readable.
Of course, the final user has the choice of {\small\tt using} {\small\tt namespace}
{\small\tt\textcolor{tag}{tag}} but beware, it has many names which may conflict
with the ones in your code.

Most tags have only lower-case letters and underscores.
The exceptions are proper names : {\small\tt \textcolor{tag}{tag}::Lagrange},
{\small\tt \textcolor{tag}{tag}::Euclid}.


          %------------------%
\section{~~Wrappers and cores}\label{\numb section 11.\numb parag 4}
          %------------------%

Designing and implementing {\maniFEM} has been a challenging endeavour.
We had a lot of fun and we have learned much along the process.

Take cells and meshes, for instance.
As explained in paragraph \ref{\numb section 1.\numb parag 2}, at the conceptual level meshes
are roughly collections of cells of the same dimension and cells are essentially
defined by their boundary which is a lower-dimensional mesh.
This conceptual simplicity does not survive to the demands of an efficient code
(although it has been extremely useful in the process of designing \maniFEM;
it should also be useful for learning and using \maniFEM).

Vertices (zero-dimensional cells) have no boundary at all.
One-dimensional cells (segments) have all the same shape and have a rudimentary boundary
(a zero-dimensional mesh consisting of a {\small\tt base} and a {\small\tt tip}).
In order to save space in the computer's memory, specific classes have been created for
vertices and for segments.

Also, there are positive cells and negative cells, positive meshes and negative meshes.
A positive cell and its negative counterpart (its {\small\tt reverse}) share some information.
To save memory space, negative cells are implemented in different classes from
positive cells, thus avoiding the storage of some of the redundant information.

We want, however, to manipulate all these different cells through a uniform interface,
which is where {\tt C++}'s inheritance and polymorphishm mechanisms come handy.
Thus, there are classes {\small\tt\verm{Cell}::Positive::Vertex},
{\small\tt\verm{Cell}::Positive::Segment} and {\small\tt\verm{Cell}::Positive::HighDim},
all derived from {\small\tt\verm{Cell}::Positive}.
And we have {\small\tt\verm{Cell}::Negative::Vertex},
{\small\tt\verm{Cell}::Negative::Segment} and {\small\tt\verm{Cell}::Negative::HighDim},
all derived from {\small\tt\verm{Cell}::Negative}.
Both {\small\tt\verm{Cell}::Positive} and {\small\tt\verm{Cell}::Negative} are derived from
{\small\tt\verm{Cell}::Core}.
% See the graph in figure \ref{\numb section 11.\numb fig 1}.
The graph below shows these inheritance relations; dotted lines represent relations subject to
the {\small\tt -DMANIFEM\_\,COLLECT\_\,CM} compilation option, explained in paragraph
\ref{\numb section 11.\numb parag 5}.

\begin{figure}[ht] \centering
 \psfrag{tag::Util::Core::Inactive}{{\small\tt\textcolor{tag}{tag}::Util::Core::Inactive}}
 \psfrag{tag::Util::Core::DelegateDispose}{{\small\tt\textcolor{tag}{tag}::Util::Core::DelegateDispose}}
 \psfrag{tag::Util::Core}{{\small\tt\textcolor{tag}{tag}::Util::Core}}
 \psfrag{Cell::Core}{{\small\tt\verm{Cell}::Core}}
 \psfrag{Cell::Negative}{{\small\tt\verm{Cell}::Negative}}
 \psfrag{Cell::Positive}{{\small\tt\verm{Cell}::Positive}}
 \psfrag{Cell::Negative::Vertex}{{\small\tt\verm{Cell}::Negative::Vertex}}
 \psfrag{Cell::Negative::NotVertex}{{\small\tt\verm{Cell}::Negative::NotVertex}}
 \psfrag{Cell::Positive::Vertex}{{\small\tt\verm{Cell}::Positive::Vertex}}
 \psfrag{Cell::Positive::NotVertex}{{\small\tt\verm{Cell}::Positive::NotVertex}}
 \psfrag{Cell::Negative::HighDim}{{\small\tt\verm{Cell}::Negative::HighDim}}
 \psfrag{Cell::Positive::HighDim}{{\small\tt\verm{Cell}::Positive::HighDim}}
 \psfrag{Cell::Negative::Segment}{{\small\tt\verm{Cell}::Negative::Segment}}
 \psfrag{Cell::Positive::Segment}{{\small\tt\verm{Cell}::Positive::Segment}}
 \includegraphics{diagr-cell-rev}
 \caption{Inheritance diagram for {\small\tt\verm{Cell}} cores}
 \label{\numb section 11.\numb fig 1}
\end{figure}

On the other hand, we want cells and meshes to be persistent objects (not subject to
syntactic scope).
We create them within some function and we want them to remain alive after returning
to the main program.
Also, they are unique entities, it does not make sense to copy them.
This is why we have implemented {\small\tt\verm{Cell}} as a thin wrapper around
{\small\tt\verm{Cell}::Core}
with most methods of {\small\tt\verm{Cell}} being delegated to {\small\tt\verm{Cell}::Core}.
When it goes out of its syntactic scope, the wrapper is destroyed but the {\small\tt\verm{Cell}::Core}
object inside remains intact (unless there are no more wrappers for that core, as explained in
paragraph \ref{\numb section 11.\numb parag 5}).
Also, you can copy the wrapper as in {\small\tt\verm{Cell}} {\small\tt A} {\small\tt =}
{\small\tt B} or {\small\tt\verm{Mesh}} {\small\tt BA} {\small\tt =} {\small\tt AB.reverse()}
but these operations do not create new core objects, they just give new names to
already existing cells or meshes (paragraph \ref{\numb section 9.\numb parag 10} gives
more details).
You can think of {\small\tt\verm{Cell}}s and {\small\tt\verm{Mesh}}es as customized pointers towards
{\small\tt\verm{Cell}::Core}s and {\small\tt\verm{Mesh}::Core}s, respectively.

Negative meshes contain no useful information; they appear mostly as boundaries
of negative cells, sometimes as interfaces between subdomains of our mesh.
Thus, there is no such class as {\small\tt\verm{Mesh}::Negative};
all {\small\tt\verm{Mesh}::Core}s are positive.
The wrapper class {\small\tt\verm{Mesh}} contains a pointer to a {\small\tt\verm{Mesh}::Core}
and a flag telling it to reverse everything if the mesh is to be considered negative.
Zero-dimensional meshes (boundaries of segments) are not stored at all.
One-dimensional meshes have often a particular structure (they are chains of segments);
when this happens they are implemented in a specialized class
{\small\tt\verm{Mesh}::Connected::OneDim}.
% See the graph in figure \ref{\numb section 11.\numb fig 2}.
The graph below shows these inheritance relations; dotted lines represent relations subject to
the {\small\tt -DMANIFEM\_\,COLLECT\_\,CM} compilation option, explained in paragraph
\ref{\numb section 11.\numb parag 5}.

\begin{figure}[ht] \centering
 \psfrag{tag::Util::Core::Inactive}{{\small\tt\textcolor{tag}{tag}::Util::Core::Inactive}}
 \psfrag{tag::Util::Core}{{\small\tt\textcolor{tag}{tag}::Util::Core}}
 \psfrag{Mesh::Core}{{\small\tt\verm{Mesh}::Core}}
 \psfrag{Mesh::NotZeroDim}{{\small\tt\verm{Mesh}::NotZeroDim}}
 \psfrag{Mesh::ZeroDim}{{\small\tt\verm{Mesh}::ZeroDim}}
 \psfrag{Mesh::Fuzzy}{{\small\tt\verm{Mesh}::Fuzzy}}
 \psfrag{Mesh::STSI}{{\small\tt\verm{Mesh}::STSI}}
 \psfrag{Mesh::Connected::OneDim}{{\small\tt\verm{Mesh}::Connected::OneDim}}
 \includegraphics{diagr-mesh-rev}
 \caption{Inheritance diagram for {\small\tt\verm{Mesh}} cores}
 \label{\numb section 11.\numb fig 2}
\end{figure}

To save memory, we don't even keep the dimension of a cell as an attribute,
it's a static property for vertices and segments, while for higher-dimensional cells
it's obtained from the boundary's dimension.
The dimension of a mesh is not kept as an attribute either; it's computed on-the-fly
by counting the levels of collections of cells the mesh is made of (and then
substracting one).
For instance, the mesh in paragraph \ref{\numb section 1.\numb parag 1} has three layers
of cells : points, segments and squares.

Constructors for wrapper classes act as factory functions for the core object.
According to their arguments, they build different core objects.

Other objects have been implemented using the same logic of wrappers and core objects :
iterators, fields, functions, manifolds.


          %------------------------%
\section{~~The lifecycle of objects}\label{\numb section 11.\numb parag 5}
          %------------------------%

Many objects in {\maniFEM} are implemented using a wrapper-core model.
Examples are {\small\tt\verm{Cell}}s, {\small\tt\verm{Mesh}}es,
{\small\tt\verm{CellIterator}}s, {\small\tt\verm{MeshIterator}}s, {\small\tt\verm{Manifold}}s,
{\small\tt\verm{Function}}s, {\small\tt\verm{FiniteElement}}s, {\small\tt\verm{Integrator}}s,%
\break {\small\tt\verm{VariationalFormulation}}s.
A garbage collector is implemented; all these classes inherit from
{\small\tt \textcolor{tag}{tag}::Util::Wrapper} and
their cores inherit from {\small\tt \textcolor{tag}{tag}::Util::Core}.
Wrappers contain a pointer to a core; each core keeps a counter of wrappers pointing to it.
The destructor of a wrapper decrements the counter and destroys the core if the counter
reaches zero.
It's like a {\small\tt shared\_\,ptr}.

Cells and meshes depend on each other in a complicated manner.
A cell keeps its boundary (which is a mesh) alive.
A mesh keeps its component cells alive.
A negative cell keeps alive its positive counterpart but the reverse does not hold;
care must be taken to break dependency cycles.

Some programs consist only in building a mesh and never (or rarely) discarding cells.
For such programs, there is no advantage in using a {\small\tt shared\_\,ptr}-like strategy.
Thus, unlike for other {\maniFEM} objects, the garbage collector for {\small\tt\verm{Cell}}s and
{\small\tt\verm{Mesh}}es can be turned off by erasing the option
{\small\tt -DMANIFEM\_\,COLLECT\_\,CM} in the {\small\tt Makefile}.
Remember to {\small\tt make} {\small\tt clean} and re-build your program;
see also paragraph \ref{\numb section 11.\numb parag 15}.
The graphs in figures \ref{\numb section 11.\numb fig 1} and \ref{\numb section 11.\numb fig 2}
show dotted lines where the inheritance relationship is subject to the
{\small\tt -DMANIFEM\_\,COLLECT\_\,CM} option.
If you turn off the garbage collector, {\small\tt\verm{Cell}}s and {\small\tt\verm{Mesh}}es
will occupy less space in the computer's memory and your program will run slightly faster.
But if you turn it off and your program does a lot of remeshing
ghost cells and meshes will fill the computer's memory (this is known as ``memory leak'').

In some examples, the garbage collector for cells and meshes does not work well :
the cell counter does not reach zero, as it should, at the end of the program.
In some cases, this happens because the finite elements are not properly destroyed.
In other cases, it has to do with the {\small\tt\verm{MetricTree}} (described in
paragraph \ref{\numb section 12.\numb parag 10}) which is not properly cleaned.


          %-------------------------%
\section{~~Different kinds of meshes}\label{\numb section 11.\numb parag 6}   
          %-------------------------%

A {\small\tt\verm{Mesh}} wrapper contains a pointer to a {\small\tt\verm{Mesh}::Core}.
The latter is a polymorphic object; there are several different kinds of meshes
which differ in their internal implementation; the wrapper provides a uniform interface
to the user (making use of virtual methods of the core).

Negative meshes are temporary wrappers built on-the-fly.
Their wrapper contains a pointer to a positive core mesh.

Zero-dimensional meshes appear only as boundaries of segment {\small\tt\verm{Cell}}s.
They are temporary objects built on-the-fly.

Some meshes are implemented as {\small\tt\verm{Mesh}::Fuzzy}.
They have as attributes lists of cells of different dimensions;
these lists have no particular order.
Iterators over cells of {\small\tt Fuzzy} meshes simply run over the respective lists of cells.

Other meshes are assumed to be connected and keep no lists of cells.
Iterators over such meshes traverse the mesh beginning at a starting point (which is an attribute
of class {\small\tt\verm{Mesh}:: ::Connected::***Dim}) and then using the neighbourhood relations
to move from one cell to another.

One-dimensional connected meshes are a special case because their topology is peculiar;
segments and vertices composing such a mesh have a natural order (linear order).
Recall that all meshes in {\maniFEM} are oriented.
A one-dimensional connected mesh can be a closed loop or an open chain of segments.
In the latter case, there is a natural starting point (the first vertex or first segment).
Iterators over such meshes are described in paragraph \ref{\numb section 9.\numb parag 4}.
The {\small\tt\verm{Mesh}} constructor with {\small\tt \textcolor{tag}{tag}::segment}
builds an open {\small\tt\verm{Mesh}::Connected::OneDim}.
Also, cell constructors with {\small\tt \textcolor{tag}{tag}::triangle} and
{\small\tt \textcolor{tag}{tag}::quadrangle} produce cells
whose boundary is a closed {\small\tt\verm{Mesh}::Connected::OneDim}.

Connected meshes of dimension two or higher are not yet implemented; for now,
{\small\tt\verm{Mesh}} constructors with {\small\tt \textcolor{tag}{tag}::rectangle} or
{\small\tt \textcolor{tag}{tag}::triangle} build a {\small\tt Fuzzy} mesh instead.
A class {\small\tt\verm{Mesh}:: ::Connected::HighDim} is object of current work.
We also intend to implement multiply connected meshes.

{\small\tt STSI} meshes are object of current work (see the graph in figure
\ref{\numb section 11.\numb fig 2}); the name means ``self-touching or self-intersecting'' meshes.
They will be used internally to implement iterators over connected high-dimensional meshes,
and for progressive meshing (described in section \ref{\numb section 3}).

Iterators over cells of a {\small\tt Fuzzy} mesh are fast because they simply run over the
list of cells of given dimension.
Iterators over {\small\tt Connected} meshes may be slower because they traverse the mesh using
neighbourhood relations between cells.
On the other hand, {\small\tt Fuzzy} meshes require more space in the computer's memory.

The kind of a certain mesh is not always completely obvious.
For instance, when {\small\tt join}ing two meshes of the kind
{\small\tt\verm{Mesh}::Connected::OneDim}, the result will be a
{\small\tt\verm{Mesh}::Connected::OneDim} if the last vertex of one of the meshes
is the same as the first vertex (reversed) of the other mesh.
Otherwise, the result will be a {\small\tt\verm{Mesh}::Fuzzy}.

Methods \ \ {\small\tt\verm{Cell}::cut\_\,from\_\,bdry\_\,of},
\ \ {\small\tt\verm{Cell}::glue\_\,on\_\,bdry\_\,of}, \ \ {\small\tt\verm{Cell}::add\_\,to\_\,mesh}
\ \ and {\small\tt\verm{Cell}::remove\_\,from\_\,mesh}
accept as second argument a {\small\tt\textcolor{tag}{tag}::do\_\,not\_\,bother}.
This tag has no effect for a fuzzy mesh.
For a connected one-dimensional mesh, the method without tag will take measures
to ensure the connectivity of the mesh and will update the total number of segments.
By providing a {\small\tt\textcolor{tag}{tag}::do\_\,not\_\,bother}, the user instructs
{\maniFEM} not to waste execution time with these details.
The user assumes responsibility for updating data members {\small\tt nb\_\,of\_\,segs},
{\small\tt first\_\,ver} and {\small\tt last\_\,ver}..
The same will apply to a high-dimensional connected mesh (object of current work).


          %-----------------------------%
\section{~~Maximum topological dimension}\label{\numb section 11.\numb parag 7}
          %-----------------------------%

\leavevmode {\ManiFEM} assumes you will not build meshes of topological dimension
above 3.
If you want to play with higher-dimensional meshes, you must relax this assumption
through the statement {\small\tt\verm{Mesh}::set\_\,max\_\,dim}
{\small\tt (}some-integer{\small\tt )}.

On the other hand, you may want to decrease the expected dimension.
Suppose you want to mesh surfaces in $ \mathbb{R}^3 $.
This means your maximum topological dimension will be 2
(this has nothing to do with the geometric dimension, here 3).
Then you may state your intention at the beginning of your program
(before building any cell, before even declaring the first vertex) through
the statement {\small\tt\verm{Mesh}::set\_\,max\_\,dim(2)}.
This will decrease the size of the {\small\tt\verm{Cell}::Core} objects in your code,
thus saving some memory.

But beware, if you try to build a mesh of dimension higher than the one expected by
\maniFEM, you will get an {\small\tt assertion} {\small\tt error} at run-time in
{\small\tt DEBUG} mode, or some bizarre behaviour (often a {\small\tt segmentation}
{\small\tt fault}) in {\small\tt NDEBUG} mode.
The {\small\tt DEBUG} mode is explained in paragraph \ref{\numb section 11.\numb parag 15}.

The geometric dimension is set by simply declaring a Euclidian manifold and building
a coordinate system on it (see e.g.\ paragraphs \ref{\numb section 1.\numb parag 1}
and \ref{\numb section 2.\numb parag 17}).


          %--------------------%
\section{~~Cores of cells and meshes}\label{\numb section 11.\numb parag 8}
          %--------------------%

As explained in paragraph \ref{\numb section 11.\numb parag 4}, the {\small\tt\verm{Cell}}
class is just a thin wrapper around a {\small\tt\verm{Cell}::Core}.
While it is possible and useful to copy {\small\tt\verm{Cell}}s (think of them as customized
pointers to {\small\tt\verm{Cell}::Core}s), objects in the {\small\tt\verm{Cell}::Core}
class cannot be copied.
Similarly, {\small\tt\verm{Mesh}} objects (wrappers) are customized pointers towards
{\small\tt\verm{Mesh}::Core}s; the latter cannot be copied.

The following classes of core cells are abstract and cannot be instantiated :
{\small\tt\verm{Cell}::Core}, {\small\tt\verm{Cell}::Positive},
{\small\tt\verm{Cell}::Core::Negative}, {\small\tt\verm{Cell}::Positive::NotVertex},
{\small\tt\verm{Cell}::Negative::NotVertex}.

The following classes of core cells can be instantiated :
{\small\tt\verm{Cell}::Positive::Vertex}, {\small\tt\verm{Cell}::Negative:: ::Vertex},
{\small\tt\verm{Cell}::Positive::Segment}, {\small\tt\verm{Cell}::Negative::Segment},
{\small\tt\verm{Cell}::Positive::HighDim},\break
{\small\tt\verm{Cell}::Negative::HighDim}.

Classes {\small\tt\verm{Mesh}::Core} and {\small\tt\verm{Mesh}::NotZeroDim} are abstract
and cannot be instatiated.

Classes {\small\tt\verm{Mesh}::ZeroDim}, {\small\tt\verm{Mesh}::Connected::OneDim} and
{\small\tt\verm{Mesh}::Fuzzy} can be instantiated.
Classes {\small\tt\verm{Mesh}::MultiplyConnected::OneDim},
{\small\tt\verm{Mesh}::Connected::HighDim}, {\small\tt\verm{Mesh}::MultiplyConneted::HighDim}
and {\small\tt\verm{Mesh}::STSI} are object of on-going work.

Note that there are no negative mesh cores.

The graphs in figures \ref{\numb section 11.\numb fig 1} and \ref{\numb section 11.\numb fig 2}
show inheritance relationships between these classes; dotted lines represent
inheritance relationships  subject to the {\small\tt -DMANIFEM\_\,COLLECT\_\,CM} option.


          %----------------------------------%
\section{~~Adding and removing cells or faces}\label{\numb section 11.\numb parag 9}
          %----------------------------------%

At a high level, we build cells and meshes using the appropriate {\small\tt\verm{Cell}} and
{\small\tt\verm{Mesh}} constructors.
At low level, cells and meshes are built by methods {\small\tt\verm{Cell}::glue\_\,on\_\,bdry\_\,of},
{\small\tt\verm{Cell}::cut\_\,from\_\,bdry\_\,of}, {\small\tt\verm{Cell}::add\_\,to\_\,mesh} and
{\small\tt\verm{Cell}::remove\_\,from\_\,mesh}.

The inlined method {\small\tt\verm{Cell}::glue\_\,on\_\,bdry\_\,of} is used for sticking a new
{\small\tt face} on the
boundary of an existing cell {\small\tt cll} (whose boundary is incomplete).
It simply calls the inlined method \ {\small\tt\verm{Cell}::Core::glue\_\,on\_\,bdry\_\,of}
which in turn calls the virtual method {\small\tt cll->glue\_\,on\_\,my\_\,bdry(face)}.
Different methods {\small\tt\verm{Cell}::***::glue\_\,on\_\,my\_\,bdry} exist for different kinds of
cells but to summarize we state that {\small\tt glue\_\,on\_\,my\_\,bdry} first calls
{\small\tt face->add\_\,to\_\,bdry} in order to add the face to the boundary of {\small\tt cll}
then calls the inline function {\small\tt add\_\,cell\_\,behind\_\,above}.

Method {\small\tt\verm{Cell}::Core::add\_\,to\_\,bdry} is virtual so it does different things for
different kinds of cells but the common idea is that it calls another virtual method
{\small\tt\verm{Mesh}::Core::add\_\,***} (the name depends on the type of cell being added).
The latter calls an inline function {\small\tt make\_\,deep\_\,connections} (hidden in an anonymous
namespace in {\small\tt mesh.cpp}) which updates fields
{\small\tt\verm{Cell}::Positive::meshes}, {\small\tt\verm{Cell}::Positive***::meshes\_\,same\_\,dim} and
{\small\tt\verm{Mesh}::Fuzzy::cells} for several pairs cell-mesh
(including cells of lower dimension and meshes of higher dimension).
After that, {\small\tt\verm{Mesh}::Core::add\_\,***} updates neighbourhood relations
coded in the map {\small\tt\verm{Cell}::Core:: ::cell\_\,behind\_\,within}.

The inlined function {\small\tt add\_\,cell\_\,behind\_\,above} deals with
the case when the cell (on whose boundary we are trying to glue a new face)
already belongs to some mesh(es).
In that case, it updates the information in {\small\tt face->cell\_\,behind\_\,within}.

If we want to add a cell to a mesh which is not a boundary of a cell (this happens
frequently in {\small\tt\verm{Mesh}} constructors),
we call the inlined method {\small\tt\verm{Cell}::add\_\,to} which calls the virtual method
{\small\tt\verm{Cell}::Core::add\_\,to\_\,mesh} which is similar to
{\small\tt\verm{Cell}::Core::add\_\,to\_\,bdry} described above.

In the constructor of a cell, since we are sure there are no meshes containing that cell
(the cell is just being built),
we call method {\small\tt add\_\,to\_\,mesh} instead of {\small\tt glue\_\,on\_\,bdry\_\,of}
(we pretend the mesh is not a boundary).

Removing a face from the boundary of an existing cell, or removing a cell from a mesh
which is not a boundary, implies a process similar to the one described above,
with methods replaced by {\small\tt\verm{Cell}::cut\_\,from\_\,bdry\_\,of},
{\small\tt\verm{Cell}::remove\_\,from\_\,mesh},
{\small\tt\verm{Cell}::Core::cut\_\,from\_\,bdry\_\,of},
{\small\tt\verm{Cell}::Core::cut\_\,from\_\,my\_\,bdry},
{\small\tt\verm{Cell}::Core::remove\_\,from\_\,bdry}, {\small\tt\verm{Cell}::Core::remove\_\,from\_\,mesh},
{\small\tt\verm{Mesh}::Core:remove\_\,***}, {\small\tt break\_\,deep\_\,connections},
{\small\tt remove\_\,cell\_\,behind\_\,above}.

Below is a very rough sketch of the process of adding a segment to the boundary of a triangle.
Note that the triangle may belong to a mesh or even to the boundary of a three-dimensional
cell which in turn may belong to a three-dimensional mesh
(cells and meshes of dimension higher than three may also show up).
Note also that the segment may be negative, just as the triangle may be negative.
Three stars {\small\tt ***} stand for either {\small\tt pos} or {\small\tt neg},
one star {\small\tt *} stands for a counter,
{\small\tt wh} stands for a pointer which for {\small\tt Fuzyy} meshes points into the
list of {\small\tt cells} while for other types of meshes is meaningless.
Often, {\small\tt tri->boundary} is a {\small\tt\verm{Mesh}::Connected::OneDim},
not a {\small\tt\verm{Mesh}::Fuzzy}, but meshes {\small\tt msh} of dimension 2 or higher
are usually {\small\tt Fuzzy}.

\def\mypm{$\pm$}
\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
seg->glue_on_bdry_of ( tri )
   tri->glue_on_my_bdry ( seg )
      seg->add_to_bdry ( tri->boundary )
         tri->boundary->add_***_seg ( seg, \textcolor{tag}{tag}::mesh_is_bdry )
            make_deep_connections_1d ( seg, tri->boundary, \textcolor{tag}{tag}::mesh_is_bdry )
               add_link_same_dim ( seg, tri->boundary )
                  tri->boundary->cells[1] .push ( seg )  // \mbox{\fontfamily{helvetica}\selectfont{}if} tri->boundary \mbox{\fontfamily{helvetica}\selectfont{}is} Fuzzy
                  seg->meshes_same_dim [ tri->boundary ] = ( \mypm1, wh )
               link_face_to_higher ( seg, tri, *, * )
                  for \azul{msh} in \{\mbox{\fontfamily{helvetica}\selectfont\,meshes of dimension} \azul{d} >= 2 \mbox{\fontfamily{helvetica}\selectfont{}containing} tri\,\}
                     add_link ( seg, msh, *, * )
                        if seg \mbox{\fontfamily{helvetica}\selectfont{}already belongs} to msh
                           \mbox{\fontfamily{helvetica}\selectfont{}increment counters}
                        else
                           msh->cells[1] .push ( seg )  // \mbox{\fontfamily{helvetica}\selectfont{}if} msh \mbox{\fontfamily{helvetica}\selectfont{}is} Fuzzy
                           seg->meshes[d] [ msh ] = ( *, *, wh )
               for \azul{ver} in \{\mbox{\fontfamily{helvetica}\selectfont\,two extremities of} seg\,\}
                  link_face_to_msh ( ver, seg, tri->boundary, *, * )
                     add_link ( ver, tri->boundary, *, * )
                        if ver \mbox{\fontfamily{helvetica}\selectfont{}already belongs to} tri->boundary
                           \mbox{\fontfamily{helvetica}\selectfont{}increment one counter}
                        else
                           tri->boundary->cells[0] .push ( ver )  // \mbox{\fontfamily{helvetica}\selectfont{}if} Fuzzy
                           ver->meshes[1] [ tri->boundary ] = ( *, *, wh )
                  link_face_to_higher ( ver, tri, *, * )
                     for \azul{msh} in \{\mbox{\fontfamily{helvetica}\selectfont\,meshes of dimension} \azul{d} >= 2 \mbox{\fontfamily{helvetica}\selectfont{}containing} tri\,\}
                        add_link ( ver, msh, *, * )
                           if ver \mbox{\fontfamily{helvetica}\selectfont{}already belongs to} msh
                              \mbox{\fontfamily{helvetica}\selectfont{}increment counters}
                           else
                              msh->cells[0] .push ( ver )  // \mbox{\fontfamily{helvetica}\selectfont{}if} msh \mbox{\fontfamily{helvetica}\selectfont{}is} Fuzzy
                              ver->meshes[d] [ msh ] = ( *, *, wh )
            add_cell_behind_below_***_seg ( seg, tri->boundary )
               for \azul{ver} in \{\mbox{\fontfamily{helvetica}\selectfont\,two extremities of} seg\,\}
                  ver->cell_behind_within [ tri->boundary ] = seg
      add_cell_behind_above ( tri, seg )
         for \azul{msh} in \{\mbox{\fontfamily{helvetica}\selectfont\,meshes of dimension} 2 \mbox{\fontfamily{helvetica}\selectfont{}containing} tri\,\}
            seg->cell_behind_within [ msh ] = tri
\end{Verbatim}

Below is a sketch of the reverse process of removing a segment from the boundary of a triangle.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
seg->cut_from_bdry_of ( tri )
   tri->cut_from_my_bdry ( seg )
      remove_cell_behind_above ( tri, seg )
         for \azul{msh} in \{\mbox{\fontfamily{helvetica}\selectfont\,meshes of dimension} \azul{d} >= 2 \mbox{\fontfamily{helvetica}\selectfont{}containing} tri\,\}
            seg->cell_behind_within .erase ( msh )
      seg->remove_from_bdry ( tri->boundary )
         tri->boundary->remove_***_seg ( seg, \textcolor{tag}{tag}::mesh_is_bdry )
            for \azul{ver} in \{\mbox{\fontfamily{helvetica}\selectfont\,two extremities of} seg\,\}
               ver->cell_behind_within .erase ( tri->boundary )
            break_deep_connections_1d ( seg, tri->boundary, \textcolor{tag}{tag}::mesh_is_bdry )
               for \azul{ver} in \{\mbox{\fontfamily{helvetica}\selectfont\,two extremities of} seg\,\}
                  unlink_face_from_msh ( ver, seg, tri->boundary, *, * )
                     remove_link ( ver, tri->boundary, *, * )
                        \mbox{\fontfamily{helvetica}\selectfont{}decrement one counter}
                        if \mbox{\fontfamily{helvetica}\selectfont{}both counters zero}
                           ver->meshes[1] .erase ( tri->boundary )
                           tri->boundary->cells[0] .remove ( ver )  // \mbox{\fontfamily{helvetica}\selectfont{}if} Fuzzy
                  unlink_face_from_higher ( ver, tri, *, * )
                     for \azul{msh} in \{\mbox{\fontfamily{helvetica}\selectfont\,meshes of dimension} \azul{d} >= 2 \mbox{\fontfamily{helvetica}\selectfont{}containing} tri\,\}
                        remove_link ( ver, msh, *, * )
                           \mbox{\fontfamily{helvetica}\selectfont{}decrement counters}
                           if \mbox{\fontfamily{helvetica}\selectfont{}both counters zero}
                              ver->meshes[d] .erase ( msh )
                              msh->cells[0] .remove ( ver )  // \mbox{\fontfamily{helvetica}\selectfont{}if} msh \mbox{\fontfamily{helvetica}\selectfont{}is} Fuzzy
               unlink_face_from_higher ( seg, tri, *, * )
                  for \azul{msh} in \{\mbox{\fontfamily{helvetica}\selectfont\,meshes of dimension} \azul{d} >= 2 \mbox{\fontfamily{helvetica}\selectfont{}containing} tri\,\}
                     remove_link ( seg, msh, *, * )
                        \mbox{\fontfamily{helvetica}\selectfont{}decrement counters}
                        if \mbox{\fontfamily{helvetica}\selectfont{}both counters zero}
                           seg->meshes[d] .erase ( msh )
                           msh->cells[1] .remove ( seg )  // \mbox{\fontfamily{helvetica}\selectfont{}if} msh \mbox{\fontfamily{helvetica}\selectfont{}is} Fuzzy
               remove_link_same_dim ( seg, tri->boundary )
                  tri->boundary->cells[1] .remove ( seg )  // \mbox{\fontfamily{helvetica}\selectfont{}if} tri->boundary \mbox{\fontfamily{helvetica}\selectfont{}is} Fuzzy
                  seg->meshes_same_dim .erase ( tri->boundary )
\end{Verbatim}


          %------------------------------%
\section{~~About {\tt init\_\,***\_\,cell}}\label{\numb section 11.\numb parag 10}
          %------------------------------%

The \ {\small\tt\verm{Cell}} \ class \ has \ static \ attributes \ {\small\tt init\_\,pos\_\,cell},
\ {\small\tt init\_\,neg\_\,cell}, \ {\small\tt data\_\,for\_\,init\_\,pos},
{\small\tt data\_\,for\_\,init\_\,neg}.
The attribute {\small\tt init\_\,pos\_\,cell} is a list of pointers to functions to be called by
the constructor of a positive cell, while {\small\tt data\_\,for\_\,init\_\,pos} is a void pointer
which can be used to pass supplementary information to {\small\tt init\_\,pos\_\,cell}.
Attributes {\small\tt init\_\,neg\_\,cell} and {\small\tt data\_\,for\_\,init\_\,neg} fulfill
a similar task when building negative cells.

For instance, the constructor of a {\small\tt\verm{FiniteElement}} with
{\small\tt\textcolor{tag}{tag}::build\_\;enum} builds a new
{\small\tt\verm{Cell}:: ::Numbering::Field} whose constructor
adds a call to {\small\tt\verm{Cell}::Numbering::Field::set\_\,and\_\,increment} to
the list {\small\tt\verm{Cell}::init\_\;pos\_\,cell[0]}.
This way, future vertices will receive automatically a {\small\tt size\_\,t} label, to be used
by Lagrange finite elements.


\section{~~\cinza{[empty]}}\label{\numb section 11.\numb parag 11}


          %-----------------%
\section{~~Programming style}\label{\numb section 11.\numb parag 12}
          %-----------------%

I (Cristian) have chosen some program-writing conventions which may seem unusual for some people.
For instance, most programmers use braces like this

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   for ( ... ) \{
      statement 1;
      statement 2;
      statement 3;
   \}
\end{Verbatim}

or perhaps like this

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   for ( ... )
   \{
      statement 1;
      statement 2;
      statement 3;
   \}
\end{Verbatim}

I just can't accept the idea that a brace opens more to the right than it closes, or at the
same point.
For me, a pair of braces should open at some point to the left and close at some point to the
right, and the statements should be between them.
That's how parentheses have been designed to be used.
So I irreverently decided that my blocks will look like this.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
   for ( ... )
   \{  statement 1;
      statement 2;
      statement 3;  \}
\end{Verbatim}

I am aware I am violating conventions which are almost universally accepted. Sorry about that.

On the other hand, I am very fussy about indentation.
I guess my mind has been formatted by Python.

{\small\tt CellIterator}s obey to syntactic rules slightly different from the conventions for
iterators in the Standard Template Library.
See paragraph \ref{\numb section 9.\numb parag 3}.

Also, the version numbering is somewhat unusual.
The version consists merely of the year and month.
Perhaps a nostalgic memory of my first serious programming language, {\tt FORTRAN 77} ?


          %-------------------------------%
\section{~~Frequent errors at compile time}\label{\numb section 11.\numb parag 13}
          %-------------------------------%

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
variable [name] set but not used [-Wunused-but-set-variables]
[name] defined but not used [-Wunused-function]
\end{Verbatim}

These are harmless warnings.

Some variables are initialized but never used.
When we create a {\small\tt\verm{Manifold}}, the constructor sets a global variable
{\small\tt\verm{Manifold}::current}.
Thus, {\maniFEM} can remember at any time the geometry of the space and it can choose the right
interpolation and projection operations.
From the compiler's viewpoint, that {\small\tt\verm{Manifold}} oject is never used again and
so it issues a warning.

Also, some functions are never used.
They are there mainly for historical reasons.
They have not been erased yet because part of their code may still be used in the future.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\normalfont\rmfamily,baselinestretch=0.94]
I get endless warnings !
\end{Verbatim}

Warnings are harmless, but when they are too many they can be a nuisance.
On some computers, {\small\tt Eigen} produces quite a lot of them.
You can turn warnings off by removing {\small\tt -W} options from your {\small\tt Makefile}.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
'class ManiFEM::tag::Util::CellCore' has no member named 'name'
-- or --
'class ManiFEM::tag::Util::CellCore' has no member named 'get_name'
\end{Verbatim}

It seems you are trying to compile your code in {\small\tt NDEBUG} mode
(see paragraph \ref{\numb section 11.\numb parag 15}).
In {\small\tt NDEBUG} mode, cells and meshes do not have names.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
cannot declare variable 'cll' to be of abstract type 'ManiFEM::tag::Util::CellCore'
-- or similar for ManiFEM::Cell::Positive or ManiFEM::Cell::Negative
   or ManiFEM::Cell::PositiveNotVertex or ManiFEM::Cell::NegativeNotVertex
   or tag::Util::MeshCore or ManiFEM::Mesh::NotZeroDim                      --
\end{Verbatim}

Classes {\small\tt\verm{Cell}::Core}, {\small\tt\verm{Cell}::Positive},
{\small\tt\verm{Cell}::Negative}, {\small\tt\verm{Cell}::Positive::NotVertex},\hfil\break
{\small\tt\verm{Cell}::Negative::NotVertex}, {\small\tt\verm{Mesh}::Core},
{\small\tt\verm{Mesh}::NotZeroDim}are abstract and cannot be instantiated.
You must be more specific; {\small\tt\verm{Cell}::Positive::Vertex},
{\small\tt\verm{Cell}::Negative::Vertex},\hfil\break
{\small\tt\verm{Cell}::Positive::Segment},
{\small\tt\verm{Cell}::Negative::Segment}, {\small\tt\verm{Cell}::Positive::HighDim},
{\small\tt\verm{Cell}::Negative::HighDim}, {\small\tt\verm{Mesh}::ZeroDim},
{\small\tt\verm{Mesh}::Connected::OneDim}, {\small\tt\verm{Mesh}::Fuzzy}
can be instantiated.
See paragraph \ref{\numb section 11.\numb parag 4}.


          %---------------------------%
\section{~~Frequent errors at run time}\label{\numb section 11.\numb parag 14}
          %---------------------------%

Many errors described in this paragraph will only show up in {\small\tt DEBUG} mode,
explained in paragraph \ref{\numb section 11.\numb parag 15}.

Some errors give explicit messages. For instance, messages like

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
only one-dimensional meshes have first vertex
-- or --
virtual maniFEM::Cell maniFEM::tag::Util::CellCore::tip(): Only segments have extremities. 
\end{Verbatim}

\noindent are self-explaining.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
double& ManiFEM::OneDimField::operator()(ManiFEM::Cell&) const:
Assertion 'cll.real_heap_size() > index_min' failed.
\end{Verbatim}

You probably tried to access a coordinate (or some other value) at a cell to which 
no value has been associated.
Either you picked a cell of a different dimension (e.g.\ a segment instead of a
vertex) or you are looking at a negative cell.
Values are usually stored at positive cells; negative cells have no information attached.
You may check if a certain cell is positive or negative by using the method
{\small\tt is\_\,positive}.
Paragraph \ref{\numb section 9.\numb parag 5} gives more details about orientation of
cells and meshes.
See also paragraphs \ref{\numb section 9.\numb parag 10} and
\ref{\numb section 11.\numb parag 4}.

Note that, if {\small\tt seg} is a segment (a one-dimensional cell), then
{\small\tt seg.tip()} is a positive cell but {\small\tt seg.base()} is a negative cell.
So, you probably need to use {\small\tt seg.base().reverse()} instead.
Iterators over cells of maximum dimension (that is, of dimension equal to the dimension
of the mesh) produce oriented cells (which may be positive or negative).
Consider using the {\small\tt \textcolor{tag}{tag}::force\_\,positive}.
See paragraphs \ref{\numb section 9.\numb parag 3} and \ref{\numb section 9.\numb parag 4}.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
assertion "this->core->reverse_attr.exists()" failed: file "mesh.h",
function: maniFEM::Cell maniFEM::Cell::reverse(const maniFEM::tag::SurelyExists&) const
-- or --
assertion "it != face.core->cell_behind_within.end()" failed: file "mesh.h",
function: maniFEM::Cell maniFEM::Mesh::cell_behind
(maniFEM::Cell, const maniFEM::tag::SurelyExists&) const
\end{Verbatim}

You may be navigating dangerously close to the boundary of a mesh.
See paragraph \ref{\numb section 9.\numb parag 7}.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,baselinestretch=0.94]
assertion "cll->meshes.size() > dif_dim" failed
-- or --
static size_t ManiFEM::tag::Util::assert_diff(const size_t, const size_t):
Assertion 'a >= b' failed.
\end{Verbatim}

You are trying to build meshes of dimension higher than those \maniFEM\ expects.
Did you re-define this expectation through the statement
{\small\tt\verm{Mesh}::set\_\,max\_\,dim} ?
Along your program, you may have different maximum topological dimensions (that is,
you may use {\small\tt\verm{Mesh}::set\_\,max\_\,dim} several times) but, at each moment,
you can only build meshes of dimension up to the value most recently defined.
See paragraph \ref{\numb section 11.\numb parag 7}.
\medskip

If {\tt gmsh} shows an empty drawing, go to {\small\tt Tools} $\to$ {\small\tt Options} $\to$
{\small\tt Mesh}.
For viewing one-dimensional meshes, you need to select {\small\tt 1D Elements}.


          %------------------%
\section{~~The {\tt DEBUG} mode and other compilation flags}
          %------------------%
\label{\numb section 11.\numb parag 15}

While you develop and test your program, you should compile it in {\small\tt DEBUG} mode.
To achieve this, simply remove any {\small\tt -dNDEBUG} option from your compilation
command (check your {\small\tt Makefile}).
Remember to {\small\tt make} {\small\tt clean} before re-building your application.

When you think your program is ready for shipping, you may want to speed it up
by adding the {\small\tt -dNDEBUG} option to your compilation command
(check your {\small\tt Makefile}).
You may also want to add other optimization options like {\small\tt -O4}.
Remember to {\small\tt make} {\small\tt clean} before re-building your application.

The garbage collector for cells and meshes (described in paragraph
\ref{\numb section 11.\numb parag 5}) can be turned on by adding the
{\small\tt -DMANIFEM\_\,COLLECT\_\,CM} compilation flag in your {\small\tt Makefile}.
To turn it off, remove the {\small\tt -DMANIFEM\_\,COLLECT\_\,CM} compilation flag.


          %------------------------%
\section{~~Compiling your own files}\label{\numb section 11.\numb parag 16}
          %------------------------%

To use \maniFEM, you should go to {\small\tt https://github.com/cristian-barbarosie/manifem},
choose a release and download all files to some directory in your computer.
Latest code may be unstable, releases are stable.
You can then run the examples in this manual :
just {\small\tt make run-\ref{\numb section 1.\numb parag 1}}
for the example in paragraph \ref{\numb section 1.\numb parag 1},
{\small\tt make run-\ref{\numb section 2.\numb parag 6}}
for the example in paragraph \ref{\numb section 2.\numb parag 6}, and so on.
You will need a recent {\tt C++} compiler (we use {\tt g++}) and the {\tt make} utility.
Under linux it should be easy to install them.
It is not that easy to install and use them under Windows, but it is certainly possible,
for instance \hbox{by using {\small\tt cygwin}},
available at {\small\tt https://www.cygwin.com/}.
Some examples use the {\small\tt Eigen} library; just copy its source tree
from {\small\tt http://eigen.tuxfamily.org/index.php? title=Main\_\,Page}
to some place in your computer and be sure that
path is mentioned in your {\small\tt Makefile}
under the {\small\tt -I} flag of your compiler.
You may also want to use {\tt gmsh}, available at {\small\tt http://gmsh.info/},
for visualization purposes.

We have chosen to put the library files in the root directory of the source code,
as well as the {\small\tt Makefile}.
The files containing the {\small\tt main} function for the examples in this manual are
grouped under the {\small\tt examples-manual} directory.
The {\small\tt Makefile} expects these {\small\tt main} files to be in that subdirectory
and expects the source files of the library itself to be in the root directory.

The user may naturally want to write their own {\small\tt main} files.
There are three ways to do this.
A quick solution is : you create your own source files and save them in the root directory
of {\maniFEM} under a name matching {\small\tt user-*.cpp},
then invoke {\small\tt make} {\small\tt run-user-*}.

The other two solutions consist in keeping \maniFEM's files separate from the files written
by the user.
Here is how to use statically linked object files.
You must create a static library file, in the {\maniFEM} source code root directory,
by issuing the command {\small\tt make static-lib}.
Then, in your working directory, you should create a {\small\tt Makefile} similar to
the one below (assuming your code is in a file {\small\tt myprog.cpp}).
After that, it suffices to issue the command {\small\tt make run}.

\begin{Verbatim}[commandchars=\\\{\},formatcom=\small\tt,frame=single,
   label=Makefile,rulecolor=\color{coment},
   baselinestretch=0.94,framesep=2mm                                            ]
\cinza{# C++ compiler}
\azul{CC} = g++

\azul{manifem_dir} = \cinza{\mbox{\fontfamily{helvetica}\selectfont{}the root directory of maniFEM}}

\cinza{# compiler flags}
\cinza{# CFLAGS = -c -I . -I $(HOME)/include/ -I $(manifem_dir) -std=c++17}
\azul{CFLAGS} = -Wshadow -Wall -c -I . -I $(HOME)/include/  -I $(manifem_dir) -std=c++17
\cinza{# CFLAGS = -DMANIFEM_COLLECT_CM -Wshadow -Wall -c -I . -I $(HOME)/include/  -I $(manifem_dir) -std=c++17}
\cinza{# CFLAGS = -DMANIFEM_COLLECT_CM -DNDEBUG -O4 -c -I . -I $(HOME)/include/ -I $(manifem_dir) -std=c++17}
\cinza{# CFLAGS = -DNDEBUG -c -O4 -I . -I $(HOME)/include/ -I $(manifem_dir) -std=c++17}
\cinza{# CFLAGS = -DNDEBUG -c -I . -I $(HOME)/include/ -I $(manifem_dir) -std=c++17}

\azul{%.o}: %.cpp
	$(CC) $(CFLAGS) $^

\azul{a.out}: myprog.o
	$(CC) $^ -L$(manifem_dir) -lmaniFEM -o a.out

\azul{run}: a.out
	./$<
\end{Verbatim}

You should be careful to use the same compilation options when compiling the library and
when compiling your main file (see paragraph \ref{\numb section 11.\numb parag 15}).
You may build two (or more) versions of the library, compiled with different options,
and keep them by copying the file {\small\tt libmaniFEM.a} under appropriate names.
Remember to {\small\tt make} {\small\tt clean} every time you want to re-build the library.
Of course you should taylor your {\small\tt Makefile} (in your own working directory)
by replacing the option {\small\tt -lmaniFEM} with the name of the particular version
of the library you want to use.

You may want to move files {\small\tt *.h} to your personal {\small\tt include} directory
(or to a subdirectory there) and {\small\tt libmaniFEM.a} to some {\small\tt lib} directory.


A third solution is to use dynamically linked object files,
but this is slightly more complicated.
See e.g.\ {\small\tt https://iq.opengenus.org/create-shared-library-in-cpp}


